// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'budget_widget.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BudgetWidget {
  String get id => throw _privateConstructorUsedError;
  String get userId => throw _privateConstructorUsedError;
  WidgetType get type => throw _privateConstructorUsedError;
  String get title => throw _privateConstructorUsedError;
  WidgetSize get size => throw _privateConstructorUsedError;
  List<WidgetData> get data => throw _privateConstructorUsedError;
  DateTime get createdAt => throw _privateConstructorUsedError;
  DateTime get updatedAt => throw _privateConstructorUsedError;
  bool get isActive => throw _privateConstructorUsedError;
  String? get backgroundColor => throw _privateConstructorUsedError;
  String? get textColor => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $BudgetWidgetCopyWith<BudgetWidget> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BudgetWidgetCopyWith<$Res> {
  factory $BudgetWidgetCopyWith(
          BudgetWidget value, $Res Function(BudgetWidget) then) =
      _$BudgetWidgetCopyWithImpl<$Res, BudgetWidget>;
  @useResult
  $Res call(
      {String id,
      String userId,
      WidgetType type,
      String title,
      WidgetSize size,
      List<WidgetData> data,
      DateTime createdAt,
      DateTime updatedAt,
      bool isActive,
      String? backgroundColor,
      String? textColor});
}

/// @nodoc
class _$BudgetWidgetCopyWithImpl<$Res, $Val extends BudgetWidget>
    implements $BudgetWidgetCopyWith<$Res> {
  _$BudgetWidgetCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? type = null,
    Object? title = null,
    Object? size = null,
    Object? data = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? isActive = null,
    Object? backgroundColor = freezed,
    Object? textColor = freezed,
  }) {
    return _then(_value.copyWith(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as WidgetSize,
      data: null == data
          ? _value.data
          : data // ignore: cast_nullable_to_non_nullable
              as List<WidgetData>,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      backgroundColor: freezed == backgroundColor
          ? _value.backgroundColor
          : backgroundColor // ignore: cast_nullable_to_non_nullable
              as String?,
      textColor: freezed == textColor
          ? _value.textColor
          : textColor // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$BudgetWidgetImplCopyWith<$Res>
    implements $BudgetWidgetCopyWith<$Res> {
  factory _$$BudgetWidgetImplCopyWith(
          _$BudgetWidgetImpl value, $Res Function(_$BudgetWidgetImpl) then) =
      __$$BudgetWidgetImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String id,
      String userId,
      WidgetType type,
      String title,
      WidgetSize size,
      List<WidgetData> data,
      DateTime createdAt,
      DateTime updatedAt,
      bool isActive,
      String? backgroundColor,
      String? textColor});
}

/// @nodoc
class __$$BudgetWidgetImplCopyWithImpl<$Res>
    extends _$BudgetWidgetCopyWithImpl<$Res, _$BudgetWidgetImpl>
    implements _$$BudgetWidgetImplCopyWith<$Res> {
  __$$BudgetWidgetImplCopyWithImpl(
      _$BudgetWidgetImpl _value, $Res Function(_$BudgetWidgetImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? id = null,
    Object? userId = null,
    Object? type = null,
    Object? title = null,
    Object? size = null,
    Object? data = null,
    Object? createdAt = null,
    Object? updatedAt = null,
    Object? isActive = null,
    Object? backgroundColor = freezed,
    Object? textColor = freezed,
  }) {
    return _then(_$BudgetWidgetImpl(
      id: null == id
          ? _value.id
          : id // ignore: cast_nullable_to_non_nullable
              as String,
      userId: null == userId
          ? _value.userId
          : userId // ignore: cast_nullable_to_non_nullable
              as String,
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
      title: null == title
          ? _value.title
          : title // ignore: cast_nullable_to_non_nullable
              as String,
      size: null == size
          ? _value.size
          : size // ignore: cast_nullable_to_non_nullable
              as WidgetSize,
      data: null == data
          ? _value._data
          : data // ignore: cast_nullable_to_non_nullable
              as List<WidgetData>,
      createdAt: null == createdAt
          ? _value.createdAt
          : createdAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      updatedAt: null == updatedAt
          ? _value.updatedAt
          : updatedAt // ignore: cast_nullable_to_non_nullable
              as DateTime,
      isActive: null == isActive
          ? _value.isActive
          : isActive // ignore: cast_nullable_to_non_nullable
              as bool,
      backgroundColor: freezed == backgroundColor
          ? _value.backgroundColor
          : backgroundColor // ignore: cast_nullable_to_non_nullable
              as String?,
      textColor: freezed == textColor
          ? _value.textColor
          : textColor // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$BudgetWidgetImpl extends _BudgetWidget {
  const _$BudgetWidgetImpl(
      {required this.id,
      required this.userId,
      required this.type,
      required this.title,
      required this.size,
      required final List<WidgetData> data,
      required this.createdAt,
      required this.updatedAt,
      this.isActive = true,
      this.backgroundColor,
      this.textColor})
      : _data = data,
        super._();

  @override
  final String id;
  @override
  final String userId;
  @override
  final WidgetType type;
  @override
  final String title;
  @override
  final WidgetSize size;
  final List<WidgetData> _data;
  @override
  List<WidgetData> get data {
    if (_data is EqualUnmodifiableListView) return _data;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_data);
  }

  @override
  final DateTime createdAt;
  @override
  final DateTime updatedAt;
  @override
  @JsonKey()
  final bool isActive;
  @override
  final String? backgroundColor;
  @override
  final String? textColor;

  @override
  String toString() {
    return 'BudgetWidget(id: $id, userId: $userId, type: $type, title: $title, size: $size, data: $data, createdAt: $createdAt, updatedAt: $updatedAt, isActive: $isActive, backgroundColor: $backgroundColor, textColor: $textColor)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BudgetWidgetImpl &&
            (identical(other.id, id) || other.id == id) &&
            (identical(other.userId, userId) || other.userId == userId) &&
            (identical(other.type, type) || other.type == type) &&
            (identical(other.title, title) || other.title == title) &&
            (identical(other.size, size) || other.size == size) &&
            const DeepCollectionEquality().equals(other._data, _data) &&
            (identical(other.createdAt, createdAt) ||
                other.createdAt == createdAt) &&
            (identical(other.updatedAt, updatedAt) ||
                other.updatedAt == updatedAt) &&
            (identical(other.isActive, isActive) ||
                other.isActive == isActive) &&
            (identical(other.backgroundColor, backgroundColor) ||
                other.backgroundColor == backgroundColor) &&
            (identical(other.textColor, textColor) ||
                other.textColor == textColor));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      id,
      userId,
      type,
      title,
      size,
      const DeepCollectionEquality().hash(_data),
      createdAt,
      updatedAt,
      isActive,
      backgroundColor,
      textColor);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BudgetWidgetImplCopyWith<_$BudgetWidgetImpl> get copyWith =>
      __$$BudgetWidgetImplCopyWithImpl<_$BudgetWidgetImpl>(this, _$identity);
}

abstract class _BudgetWidget extends BudgetWidget {
  const factory _BudgetWidget(
      {required final String id,
      required final String userId,
      required final WidgetType type,
      required final String title,
      required final WidgetSize size,
      required final List<WidgetData> data,
      required final DateTime createdAt,
      required final DateTime updatedAt,
      final bool isActive,
      final String? backgroundColor,
      final String? textColor}) = _$BudgetWidgetImpl;
  const _BudgetWidget._() : super._();

  @override
  String get id;
  @override
  String get userId;
  @override
  WidgetType get type;
  @override
  String get title;
  @override
  WidgetSize get size;
  @override
  List<WidgetData> get data;
  @override
  DateTime get createdAt;
  @override
  DateTime get updatedAt;
  @override
  bool get isActive;
  @override
  String? get backgroundColor;
  @override
  String? get textColor;
  @override
  @JsonKey(ignore: true)
  _$$BudgetWidgetImplCopyWith<_$BudgetWidgetImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WidgetData {
  String get key => throw _privateConstructorUsedError;
  String get value => throw _privateConstructorUsedError;
  String get label => throw _privateConstructorUsedError;
  String? get unit => throw _privateConstructorUsedError;
  String? get color => throw _privateConstructorUsedError;
  bool get isPrimary => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WidgetDataCopyWith<WidgetData> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidgetDataCopyWith<$Res> {
  factory $WidgetDataCopyWith(
          WidgetData value, $Res Function(WidgetData) then) =
      _$WidgetDataCopyWithImpl<$Res, WidgetData>;
  @useResult
  $Res call(
      {String key,
      String value,
      String label,
      String? unit,
      String? color,
      bool isPrimary});
}

/// @nodoc
class _$WidgetDataCopyWithImpl<$Res, $Val extends WidgetData>
    implements $WidgetDataCopyWith<$Res> {
  _$WidgetDataCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? value = null,
    Object? label = null,
    Object? unit = freezed,
    Object? color = freezed,
    Object? isPrimary = null,
  }) {
    return _then(_value.copyWith(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      label: null == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      isPrimary: null == isPrimary
          ? _value.isPrimary
          : isPrimary // ignore: cast_nullable_to_non_nullable
              as bool,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WidgetDataImplCopyWith<$Res>
    implements $WidgetDataCopyWith<$Res> {
  factory _$$WidgetDataImplCopyWith(
          _$WidgetDataImpl value, $Res Function(_$WidgetDataImpl) then) =
      __$$WidgetDataImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {String key,
      String value,
      String label,
      String? unit,
      String? color,
      bool isPrimary});
}

/// @nodoc
class __$$WidgetDataImplCopyWithImpl<$Res>
    extends _$WidgetDataCopyWithImpl<$Res, _$WidgetDataImpl>
    implements _$$WidgetDataImplCopyWith<$Res> {
  __$$WidgetDataImplCopyWithImpl(
      _$WidgetDataImpl _value, $Res Function(_$WidgetDataImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? key = null,
    Object? value = null,
    Object? label = null,
    Object? unit = freezed,
    Object? color = freezed,
    Object? isPrimary = null,
  }) {
    return _then(_$WidgetDataImpl(
      key: null == key
          ? _value.key
          : key // ignore: cast_nullable_to_non_nullable
              as String,
      value: null == value
          ? _value.value
          : value // ignore: cast_nullable_to_non_nullable
              as String,
      label: null == label
          ? _value.label
          : label // ignore: cast_nullable_to_non_nullable
              as String,
      unit: freezed == unit
          ? _value.unit
          : unit // ignore: cast_nullable_to_non_nullable
              as String?,
      color: freezed == color
          ? _value.color
          : color // ignore: cast_nullable_to_non_nullable
              as String?,
      isPrimary: null == isPrimary
          ? _value.isPrimary
          : isPrimary // ignore: cast_nullable_to_non_nullable
              as bool,
    ));
  }
}

/// @nodoc

class _$WidgetDataImpl extends _WidgetData {
  const _$WidgetDataImpl(
      {required this.key,
      required this.value,
      required this.label,
      this.unit,
      this.color,
      this.isPrimary = false})
      : super._();

  @override
  final String key;
  @override
  final String value;
  @override
  final String label;
  @override
  final String? unit;
  @override
  final String? color;
  @override
  @JsonKey()
  final bool isPrimary;

  @override
  String toString() {
    return 'WidgetData(key: $key, value: $value, label: $label, unit: $unit, color: $color, isPrimary: $isPrimary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetDataImpl &&
            (identical(other.key, key) || other.key == key) &&
            (identical(other.value, value) || other.value == value) &&
            (identical(other.label, label) || other.label == label) &&
            (identical(other.unit, unit) || other.unit == unit) &&
            (identical(other.color, color) || other.color == color) &&
            (identical(other.isPrimary, isPrimary) ||
                other.isPrimary == isPrimary));
  }

  @override
  int get hashCode =>
      Object.hash(runtimeType, key, value, label, unit, color, isPrimary);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetDataImplCopyWith<_$WidgetDataImpl> get copyWith =>
      __$$WidgetDataImplCopyWithImpl<_$WidgetDataImpl>(this, _$identity);
}

abstract class _WidgetData extends WidgetData {
  const factory _WidgetData(
      {required final String key,
      required final String value,
      required final String label,
      final String? unit,
      final String? color,
      final bool isPrimary}) = _$WidgetDataImpl;
  const _WidgetData._() : super._();

  @override
  String get key;
  @override
  String get value;
  @override
  String get label;
  @override
  String? get unit;
  @override
  String? get color;
  @override
  bool get isPrimary;
  @override
  @JsonKey(ignore: true)
  _$$WidgetDataImplCopyWith<_$WidgetDataImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$WidgetConfig {
  WidgetType get type => throw _privateConstructorUsedError;
  List<String> get requiredDataKeys => throw _privateConstructorUsedError;
  Map<String, String> get defaultLabels => throw _privateConstructorUsedError;
  WidgetSize get defaultSize => throw _privateConstructorUsedError;
  String? get description => throw _privateConstructorUsedError;

  @JsonKey(ignore: true)
  $WidgetConfigCopyWith<WidgetConfig> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $WidgetConfigCopyWith<$Res> {
  factory $WidgetConfigCopyWith(
          WidgetConfig value, $Res Function(WidgetConfig) then) =
      _$WidgetConfigCopyWithImpl<$Res, WidgetConfig>;
  @useResult
  $Res call(
      {WidgetType type,
      List<String> requiredDataKeys,
      Map<String, String> defaultLabels,
      WidgetSize defaultSize,
      String? description});
}

/// @nodoc
class _$WidgetConfigCopyWithImpl<$Res, $Val extends WidgetConfig>
    implements $WidgetConfigCopyWith<$Res> {
  _$WidgetConfigCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? requiredDataKeys = null,
    Object? defaultLabels = null,
    Object? defaultSize = null,
    Object? description = freezed,
  }) {
    return _then(_value.copyWith(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
      requiredDataKeys: null == requiredDataKeys
          ? _value.requiredDataKeys
          : requiredDataKeys // ignore: cast_nullable_to_non_nullable
              as List<String>,
      defaultLabels: null == defaultLabels
          ? _value.defaultLabels
          : defaultLabels // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      defaultSize: null == defaultSize
          ? _value.defaultSize
          : defaultSize // ignore: cast_nullable_to_non_nullable
              as WidgetSize,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ) as $Val);
  }
}

/// @nodoc
abstract class _$$WidgetConfigImplCopyWith<$Res>
    implements $WidgetConfigCopyWith<$Res> {
  factory _$$WidgetConfigImplCopyWith(
          _$WidgetConfigImpl value, $Res Function(_$WidgetConfigImpl) then) =
      __$$WidgetConfigImplCopyWithImpl<$Res>;
  @override
  @useResult
  $Res call(
      {WidgetType type,
      List<String> requiredDataKeys,
      Map<String, String> defaultLabels,
      WidgetSize defaultSize,
      String? description});
}

/// @nodoc
class __$$WidgetConfigImplCopyWithImpl<$Res>
    extends _$WidgetConfigCopyWithImpl<$Res, _$WidgetConfigImpl>
    implements _$$WidgetConfigImplCopyWith<$Res> {
  __$$WidgetConfigImplCopyWithImpl(
      _$WidgetConfigImpl _value, $Res Function(_$WidgetConfigImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? type = null,
    Object? requiredDataKeys = null,
    Object? defaultLabels = null,
    Object? defaultSize = null,
    Object? description = freezed,
  }) {
    return _then(_$WidgetConfigImpl(
      type: null == type
          ? _value.type
          : type // ignore: cast_nullable_to_non_nullable
              as WidgetType,
      requiredDataKeys: null == requiredDataKeys
          ? _value._requiredDataKeys
          : requiredDataKeys // ignore: cast_nullable_to_non_nullable
              as List<String>,
      defaultLabels: null == defaultLabels
          ? _value._defaultLabels
          : defaultLabels // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
      defaultSize: null == defaultSize
          ? _value.defaultSize
          : defaultSize // ignore: cast_nullable_to_non_nullable
              as WidgetSize,
      description: freezed == description
          ? _value.description
          : description // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$WidgetConfigImpl extends _WidgetConfig {
  const _$WidgetConfigImpl(
      {required this.type,
      required final List<String> requiredDataKeys,
      required final Map<String, String> defaultLabels,
      required this.defaultSize,
      this.description})
      : _requiredDataKeys = requiredDataKeys,
        _defaultLabels = defaultLabels,
        super._();

  @override
  final WidgetType type;
  final List<String> _requiredDataKeys;
  @override
  List<String> get requiredDataKeys {
    if (_requiredDataKeys is EqualUnmodifiableListView)
      return _requiredDataKeys;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_requiredDataKeys);
  }

  final Map<String, String> _defaultLabels;
  @override
  Map<String, String> get defaultLabels {
    if (_defaultLabels is EqualUnmodifiableMapView) return _defaultLabels;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_defaultLabels);
  }

  @override
  final WidgetSize defaultSize;
  @override
  final String? description;

  @override
  String toString() {
    return 'WidgetConfig(type: $type, requiredDataKeys: $requiredDataKeys, defaultLabels: $defaultLabels, defaultSize: $defaultSize, description: $description)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$WidgetConfigImpl &&
            (identical(other.type, type) || other.type == type) &&
            const DeepCollectionEquality()
                .equals(other._requiredDataKeys, _requiredDataKeys) &&
            const DeepCollectionEquality()
                .equals(other._defaultLabels, _defaultLabels) &&
            (identical(other.defaultSize, defaultSize) ||
                other.defaultSize == defaultSize) &&
            (identical(other.description, description) ||
                other.description == description));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      type,
      const DeepCollectionEquality().hash(_requiredDataKeys),
      const DeepCollectionEquality().hash(_defaultLabels),
      defaultSize,
      description);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$WidgetConfigImplCopyWith<_$WidgetConfigImpl> get copyWith =>
      __$$WidgetConfigImplCopyWithImpl<_$WidgetConfigImpl>(this, _$identity);
}

abstract class _WidgetConfig extends WidgetConfig {
  const factory _WidgetConfig(
      {required final WidgetType type,
      required final List<String> requiredDataKeys,
      required final Map<String, String> defaultLabels,
      required final WidgetSize defaultSize,
      final String? description}) = _$WidgetConfigImpl;
  const _WidgetConfig._() : super._();

  @override
  WidgetType get type;
  @override
  List<String> get requiredDataKeys;
  @override
  Map<String, String> get defaultLabels;
  @override
  WidgetSize get defaultSize;
  @override
  String? get description;
  @override
  @JsonKey(ignore: true)
  _$$WidgetConfigImplCopyWith<_$WidgetConfigImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
