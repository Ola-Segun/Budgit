// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'bill_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$BillState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BillStateCopyWith<$Res> {
  factory $BillStateCopyWith(BillState value, $Res Function(BillState) then) =
      _$BillStateCopyWithImpl<$Res, BillState>;
}

/// @nodoc
class _$BillStateCopyWithImpl<$Res, $Val extends BillState>
    implements $BillStateCopyWith<$Res> {
  _$BillStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'BillState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements BillState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'BillState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements BillState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<Bill> bills, BillsSummary summary});

  $BillsSummaryCopyWith<$Res> get summary;
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bills = null,
    Object? summary = null,
  }) {
    return _then(_$LoadedImpl(
      bills: null == bills
          ? _value._bills
          : bills // ignore: cast_nullable_to_non_nullable
              as List<Bill>,
      summary: null == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as BillsSummary,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillsSummaryCopyWith<$Res> get summary {
    return $BillsSummaryCopyWith<$Res>(_value.summary, (value) {
      return _then(_value.copyWith(summary: value));
    });
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl({required final List<Bill> bills, required this.summary})
      : _bills = bills;

  final List<Bill> _bills;
  @override
  List<Bill> get bills {
    if (_bills is EqualUnmodifiableListView) return _bills;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_bills);
  }

  @override
  final BillsSummary summary;

  @override
  String toString() {
    return 'BillState.loaded(bills: $bills, summary: $summary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality().equals(other._bills, _bills) &&
            (identical(other.summary, summary) || other.summary == summary));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_bills), summary);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return loaded(bills, summary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return loaded?.call(bills, summary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(bills, summary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements BillState {
  const factory _Loaded(
      {required final List<Bill> bills,
      required final BillsSummary summary}) = _$LoadedImpl;

  List<Bill> get bills;
  BillsSummary get summary;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, List<Bill>? bills, BillsSummary? summary});

  $BillsSummaryCopyWith<$Res>? get summary;
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? bills = freezed,
    Object? summary = freezed,
  }) {
    return _then(_$ErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      bills: freezed == bills
          ? _value._bills
          : bills // ignore: cast_nullable_to_non_nullable
              as List<Bill>?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as BillsSummary?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillsSummaryCopyWith<$Res>? get summary {
    if (_value.summary == null) {
      return null;
    }

    return $BillsSummaryCopyWith<$Res>(_value.summary!, (value) {
      return _then(_value.copyWith(summary: value));
    });
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl(
      {required this.message, final List<Bill>? bills, this.summary})
      : _bills = bills;

  @override
  final String message;
  final List<Bill>? _bills;
  @override
  List<Bill>? get bills {
    final value = _bills;
    if (value == null) return null;
    if (_bills is EqualUnmodifiableListView) return _bills;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final BillsSummary? summary;

  @override
  String toString() {
    return 'BillState.error(message: $message, bills: $bills, summary: $summary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._bills, _bills) &&
            (identical(other.summary, summary) || other.summary == summary));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message,
      const DeepCollectionEquality().hash(_bills), summary);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return error(message, bills, summary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return error?.call(message, bills, summary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, bills, summary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements BillState {
  const factory _Error(
      {required final String message,
      final List<Bill>? bills,
      final BillsSummary? summary}) = _$ErrorImpl;

  String get message;
  List<Bill>? get bills;
  BillsSummary? get summary;
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BillLoadedImplCopyWith<$Res> {
  factory _$$BillLoadedImplCopyWith(
          _$BillLoadedImpl value, $Res Function(_$BillLoadedImpl) then) =
      __$$BillLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill bill, BillStatus status});

  $BillCopyWith<$Res> get bill;
  $BillStatusCopyWith<$Res> get status;
}

/// @nodoc
class __$$BillLoadedImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$BillLoadedImpl>
    implements _$$BillLoadedImplCopyWith<$Res> {
  __$$BillLoadedImplCopyWithImpl(
      _$BillLoadedImpl _value, $Res Function(_$BillLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = null,
    Object? status = null,
  }) {
    return _then(_$BillLoadedImpl(
      bill: null == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as BillStatus,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res> get bill {
    return $BillCopyWith<$Res>(_value.bill, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $BillStatusCopyWith<$Res> get status {
    return $BillStatusCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

/// @nodoc

class _$BillLoadedImpl implements _BillLoaded {
  const _$BillLoadedImpl({required this.bill, required this.status});

  @override
  final Bill bill;
  @override
  final BillStatus status;

  @override
  String toString() {
    return 'BillState.billLoaded(bill: $bill, status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BillLoadedImpl &&
            (identical(other.bill, bill) || other.bill == bill) &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BillLoadedImplCopyWith<_$BillLoadedImpl> get copyWith =>
      __$$BillLoadedImplCopyWithImpl<_$BillLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return billLoaded(bill, status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return billLoaded?.call(bill, status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (billLoaded != null) {
      return billLoaded(bill, status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return billLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return billLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (billLoaded != null) {
      return billLoaded(this);
    }
    return orElse();
  }
}

abstract class _BillLoaded implements BillState {
  const factory _BillLoaded(
      {required final Bill bill,
      required final BillStatus status}) = _$BillLoadedImpl;

  Bill get bill;
  BillStatus get status;
  @JsonKey(ignore: true)
  _$$BillLoadedImplCopyWith<_$BillLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BillSavedImplCopyWith<$Res> {
  factory _$$BillSavedImplCopyWith(
          _$BillSavedImpl value, $Res Function(_$BillSavedImpl) then) =
      __$$BillSavedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill bill});

  $BillCopyWith<$Res> get bill;
}

/// @nodoc
class __$$BillSavedImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$BillSavedImpl>
    implements _$$BillSavedImplCopyWith<$Res> {
  __$$BillSavedImplCopyWithImpl(
      _$BillSavedImpl _value, $Res Function(_$BillSavedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = null,
  }) {
    return _then(_$BillSavedImpl(
      bill: null == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res> get bill {
    return $BillCopyWith<$Res>(_value.bill, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }
}

/// @nodoc

class _$BillSavedImpl implements _BillSaved {
  const _$BillSavedImpl({required this.bill});

  @override
  final Bill bill;

  @override
  String toString() {
    return 'BillState.billSaved(bill: $bill)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$BillSavedImpl &&
            (identical(other.bill, bill) || other.bill == bill));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$BillSavedImplCopyWith<_$BillSavedImpl> get copyWith =>
      __$$BillSavedImplCopyWithImpl<_$BillSavedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return billSaved(bill);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return billSaved?.call(bill);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (billSaved != null) {
      return billSaved(bill);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return billSaved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return billSaved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (billSaved != null) {
      return billSaved(this);
    }
    return orElse();
  }
}

abstract class _BillSaved implements BillState {
  const factory _BillSaved({required final Bill bill}) = _$BillSavedImpl;

  Bill get bill;
  @JsonKey(ignore: true)
  _$$BillSavedImplCopyWith<_$BillSavedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$BillDeletedImplCopyWith<$Res> {
  factory _$$BillDeletedImplCopyWith(
          _$BillDeletedImpl value, $Res Function(_$BillDeletedImpl) then) =
      __$$BillDeletedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$BillDeletedImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$BillDeletedImpl>
    implements _$$BillDeletedImplCopyWith<$Res> {
  __$$BillDeletedImplCopyWithImpl(
      _$BillDeletedImpl _value, $Res Function(_$BillDeletedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$BillDeletedImpl implements _BillDeleted {
  const _$BillDeletedImpl();

  @override
  String toString() {
    return 'BillState.billDeleted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$BillDeletedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return billDeleted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return billDeleted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (billDeleted != null) {
      return billDeleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return billDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return billDeleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (billDeleted != null) {
      return billDeleted(this);
    }
    return orElse();
  }
}

abstract class _BillDeleted implements BillState {
  const factory _BillDeleted() = _$BillDeletedImpl;
}

/// @nodoc
abstract class _$$PaymentMarkedImplCopyWith<$Res> {
  factory _$$PaymentMarkedImplCopyWith(
          _$PaymentMarkedImpl value, $Res Function(_$PaymentMarkedImpl) then) =
      __$$PaymentMarkedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill bill});

  $BillCopyWith<$Res> get bill;
}

/// @nodoc
class __$$PaymentMarkedImplCopyWithImpl<$Res>
    extends _$BillStateCopyWithImpl<$Res, _$PaymentMarkedImpl>
    implements _$$PaymentMarkedImplCopyWith<$Res> {
  __$$PaymentMarkedImplCopyWithImpl(
      _$PaymentMarkedImpl _value, $Res Function(_$PaymentMarkedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = null,
  }) {
    return _then(_$PaymentMarkedImpl(
      bill: null == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res> get bill {
    return $BillCopyWith<$Res>(_value.bill, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }
}

/// @nodoc

class _$PaymentMarkedImpl implements _PaymentMarked {
  const _$PaymentMarkedImpl({required this.bill});

  @override
  final Bill bill;

  @override
  String toString() {
    return 'BillState.paymentMarked(bill: $bill)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentMarkedImpl &&
            (identical(other.bill, bill) || other.bill == bill));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentMarkedImplCopyWith<_$PaymentMarkedImpl> get copyWith =>
      __$$PaymentMarkedImplCopyWithImpl<_$PaymentMarkedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<Bill> bills, BillsSummary summary) loaded,
    required TResult Function(
            String message, List<Bill>? bills, BillsSummary? summary)
        error,
    required TResult Function(Bill bill, BillStatus status) billLoaded,
    required TResult Function(Bill bill) billSaved,
    required TResult Function() billDeleted,
    required TResult Function(Bill bill) paymentMarked,
  }) {
    return paymentMarked(bill);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult? Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult? Function(Bill bill, BillStatus status)? billLoaded,
    TResult? Function(Bill bill)? billSaved,
    TResult? Function()? billDeleted,
    TResult? Function(Bill bill)? paymentMarked,
  }) {
    return paymentMarked?.call(bill);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<Bill> bills, BillsSummary summary)? loaded,
    TResult Function(String message, List<Bill>? bills, BillsSummary? summary)?
        error,
    TResult Function(Bill bill, BillStatus status)? billLoaded,
    TResult Function(Bill bill)? billSaved,
    TResult Function()? billDeleted,
    TResult Function(Bill bill)? paymentMarked,
    required TResult orElse(),
  }) {
    if (paymentMarked != null) {
      return paymentMarked(bill);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_BillLoaded value) billLoaded,
    required TResult Function(_BillSaved value) billSaved,
    required TResult Function(_BillDeleted value) billDeleted,
    required TResult Function(_PaymentMarked value) paymentMarked,
  }) {
    return paymentMarked(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_BillLoaded value)? billLoaded,
    TResult? Function(_BillSaved value)? billSaved,
    TResult? Function(_BillDeleted value)? billDeleted,
    TResult? Function(_PaymentMarked value)? paymentMarked,
  }) {
    return paymentMarked?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_BillLoaded value)? billLoaded,
    TResult Function(_BillSaved value)? billSaved,
    TResult Function(_BillDeleted value)? billDeleted,
    TResult Function(_PaymentMarked value)? paymentMarked,
    required TResult orElse(),
  }) {
    if (paymentMarked != null) {
      return paymentMarked(this);
    }
    return orElse();
  }
}

abstract class _PaymentMarked implements BillState {
  const factory _PaymentMarked({required final Bill bill}) =
      _$PaymentMarkedImpl;

  Bill get bill;
  @JsonKey(ignore: true)
  _$$PaymentMarkedImplCopyWith<_$PaymentMarkedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BillFormState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BillFormStateCopyWith<$Res> {
  factory $BillFormStateCopyWith(
          BillFormState value, $Res Function(BillFormState) then) =
      _$BillFormStateCopyWithImpl<$Res, BillFormState>;
}

/// @nodoc
class _$BillFormStateCopyWithImpl<$Res, $Val extends BillFormState>
    implements $BillFormStateCopyWith<$Res> {
  _$BillFormStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FormInitialImplCopyWith<$Res> {
  factory _$$FormInitialImplCopyWith(
          _$FormInitialImpl value, $Res Function(_$FormInitialImpl) then) =
      __$$FormInitialImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill? bill});

  $BillCopyWith<$Res>? get bill;
}

/// @nodoc
class __$$FormInitialImplCopyWithImpl<$Res>
    extends _$BillFormStateCopyWithImpl<$Res, _$FormInitialImpl>
    implements _$$FormInitialImplCopyWith<$Res> {
  __$$FormInitialImplCopyWithImpl(
      _$FormInitialImpl _value, $Res Function(_$FormInitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = freezed,
  }) {
    return _then(_$FormInitialImpl(
      bill: freezed == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res>? get bill {
    if (_value.bill == null) {
      return null;
    }

    return $BillCopyWith<$Res>(_value.bill!, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }
}

/// @nodoc

class _$FormInitialImpl implements _FormInitial {
  const _$FormInitialImpl({this.bill});

  @override
  final Bill? bill;

  @override
  String toString() {
    return 'BillFormState.initial(bill: $bill)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormInitialImpl &&
            (identical(other.bill, bill) || other.bill == bill));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormInitialImplCopyWith<_$FormInitialImpl> get copyWith =>
      __$$FormInitialImplCopyWithImpl<_$FormInitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) {
    return initial(bill);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) {
    return initial?.call(bill);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(bill);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FormInitial implements BillFormState {
  const factory _FormInitial({final Bill? bill}) = _$FormInitialImpl;

  Bill? get bill;
  @JsonKey(ignore: true)
  _$$FormInitialImplCopyWith<_$FormInitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormLoadingImplCopyWith<$Res> {
  factory _$$FormLoadingImplCopyWith(
          _$FormLoadingImpl value, $Res Function(_$FormLoadingImpl) then) =
      __$$FormLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FormLoadingImplCopyWithImpl<$Res>
    extends _$BillFormStateCopyWithImpl<$Res, _$FormLoadingImpl>
    implements _$$FormLoadingImplCopyWith<$Res> {
  __$$FormLoadingImplCopyWithImpl(
      _$FormLoadingImpl _value, $Res Function(_$FormLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FormLoadingImpl implements _FormLoading {
  const _$FormLoadingImpl();

  @override
  String toString() {
    return 'BillFormState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FormLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FormLoading implements BillFormState {
  const factory _FormLoading() = _$FormLoadingImpl;
}

/// @nodoc
abstract class _$$FormSavedImplCopyWith<$Res> {
  factory _$$FormSavedImplCopyWith(
          _$FormSavedImpl value, $Res Function(_$FormSavedImpl) then) =
      __$$FormSavedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill bill});

  $BillCopyWith<$Res> get bill;
}

/// @nodoc
class __$$FormSavedImplCopyWithImpl<$Res>
    extends _$BillFormStateCopyWithImpl<$Res, _$FormSavedImpl>
    implements _$$FormSavedImplCopyWith<$Res> {
  __$$FormSavedImplCopyWithImpl(
      _$FormSavedImpl _value, $Res Function(_$FormSavedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = null,
  }) {
    return _then(_$FormSavedImpl(
      bill: null == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res> get bill {
    return $BillCopyWith<$Res>(_value.bill, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }
}

/// @nodoc

class _$FormSavedImpl implements _FormSaved {
  const _$FormSavedImpl({required this.bill});

  @override
  final Bill bill;

  @override
  String toString() {
    return 'BillFormState.saved(bill: $bill)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormSavedImpl &&
            (identical(other.bill, bill) || other.bill == bill));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormSavedImplCopyWith<_$FormSavedImpl> get copyWith =>
      __$$FormSavedImplCopyWithImpl<_$FormSavedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) {
    return saved(bill);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) {
    return saved?.call(bill);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(bill);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return saved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return saved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(this);
    }
    return orElse();
  }
}

abstract class _FormSaved implements BillFormState {
  const factory _FormSaved({required final Bill bill}) = _$FormSavedImpl;

  Bill get bill;
  @JsonKey(ignore: true)
  _$$FormSavedImplCopyWith<_$FormSavedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormErrorImplCopyWith<$Res> {
  factory _$$FormErrorImplCopyWith(
          _$FormErrorImpl value, $Res Function(_$FormErrorImpl) then) =
      __$$FormErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, Map<String, String> errors});
}

/// @nodoc
class __$$FormErrorImplCopyWithImpl<$Res>
    extends _$BillFormStateCopyWithImpl<$Res, _$FormErrorImpl>
    implements _$$FormErrorImplCopyWith<$Res> {
  __$$FormErrorImplCopyWithImpl(
      _$FormErrorImpl _value, $Res Function(_$FormErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? errors = null,
  }) {
    return _then(_$FormErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      errors: null == errors
          ? _value._errors
          : errors // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc

class _$FormErrorImpl implements _FormError {
  const _$FormErrorImpl(
      {required this.message, required final Map<String, String> errors})
      : _errors = errors;

  @override
  final String message;
  final Map<String, String> _errors;
  @override
  Map<String, String> get errors {
    if (_errors is EqualUnmodifiableMapView) return _errors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_errors);
  }

  @override
  String toString() {
    return 'BillFormState.error(message: $message, errors: $errors)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._errors, _errors));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, message, const DeepCollectionEquality().hash(_errors));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormErrorImplCopyWith<_$FormErrorImpl> get copyWith =>
      __$$FormErrorImplCopyWithImpl<_$FormErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) {
    return error(message, errors);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) {
    return error?.call(message, errors);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, errors);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FormError implements BillFormState {
  const factory _FormError(
      {required final String message,
      required final Map<String, String> errors}) = _$FormErrorImpl;

  String get message;
  Map<String, String> get errors;
  @JsonKey(ignore: true)
  _$$FormErrorImplCopyWith<_$FormErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormValidatingImplCopyWith<$Res> {
  factory _$$FormValidatingImplCopyWith(_$FormValidatingImpl value,
          $Res Function(_$FormValidatingImpl) then) =
      __$$FormValidatingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FormValidatingImplCopyWithImpl<$Res>
    extends _$BillFormStateCopyWithImpl<$Res, _$FormValidatingImpl>
    implements _$$FormValidatingImplCopyWith<$Res> {
  __$$FormValidatingImplCopyWithImpl(
      _$FormValidatingImpl _value, $Res Function(_$FormValidatingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FormValidatingImpl implements _FormValidating {
  const _$FormValidatingImpl();

  @override
  String toString() {
    return 'BillFormState.validating()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FormValidatingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) {
    return validating();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) {
    return validating?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) {
    if (validating != null) {
      return validating();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return validating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return validating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (validating != null) {
      return validating(this);
    }
    return orElse();
  }
}

abstract class _FormValidating implements BillFormState {
  const factory _FormValidating() = _$FormValidatingImpl;
}

/// @nodoc
abstract class _$$FormValidImplCopyWith<$Res> {
  factory _$$FormValidImplCopyWith(
          _$FormValidImpl value, $Res Function(_$FormValidImpl) then) =
      __$$FormValidImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill bill});

  $BillCopyWith<$Res> get bill;
}

/// @nodoc
class __$$FormValidImplCopyWithImpl<$Res>
    extends _$BillFormStateCopyWithImpl<$Res, _$FormValidImpl>
    implements _$$FormValidImplCopyWith<$Res> {
  __$$FormValidImplCopyWithImpl(
      _$FormValidImpl _value, $Res Function(_$FormValidImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = null,
  }) {
    return _then(_$FormValidImpl(
      bill: null == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res> get bill {
    return $BillCopyWith<$Res>(_value.bill, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }
}

/// @nodoc

class _$FormValidImpl implements _FormValid {
  const _$FormValidImpl({required this.bill});

  @override
  final Bill bill;

  @override
  String toString() {
    return 'BillFormState.valid(bill: $bill)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormValidImpl &&
            (identical(other.bill, bill) || other.bill == bill));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormValidImplCopyWith<_$FormValidImpl> get copyWith =>
      __$$FormValidImplCopyWithImpl<_$FormValidImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(Bill? bill) initial,
    required TResult Function() loading,
    required TResult Function(Bill bill) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(Bill bill) valid,
  }) {
    return valid(bill);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(Bill? bill)? initial,
    TResult? Function()? loading,
    TResult? Function(Bill bill)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(Bill bill)? valid,
  }) {
    return valid?.call(bill);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(Bill? bill)? initial,
    TResult Function()? loading,
    TResult Function(Bill bill)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(Bill bill)? valid,
    required TResult orElse(),
  }) {
    if (valid != null) {
      return valid(bill);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return valid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return valid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (valid != null) {
      return valid(this);
    }
    return orElse();
  }
}

abstract class _FormValid implements BillFormState {
  const factory _FormValid({required final Bill bill}) = _$FormValidImpl;

  Bill get bill;
  @JsonKey(ignore: true)
  _$$FormValidImplCopyWith<_$FormValidImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$BillsListState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BillsListStateCopyWith<$Res> {
  factory $BillsListStateCopyWith(
          BillsListState value, $Res Function(BillsListState) then) =
      _$BillsListStateCopyWithImpl<$Res, BillsListState>;
}

/// @nodoc
class _$BillsListStateCopyWithImpl<$Res, $Val extends BillsListState>
    implements $BillsListStateCopyWith<$Res> {
  _$BillsListStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ListInitialImplCopyWith<$Res> {
  factory _$$ListInitialImplCopyWith(
          _$ListInitialImpl value, $Res Function(_$ListInitialImpl) then) =
      __$$ListInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ListInitialImplCopyWithImpl<$Res>
    extends _$BillsListStateCopyWithImpl<$Res, _$ListInitialImpl>
    implements _$$ListInitialImplCopyWith<$Res> {
  __$$ListInitialImplCopyWithImpl(
      _$ListInitialImpl _value, $Res Function(_$ListInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ListInitialImpl implements _ListInitial {
  const _$ListInitialImpl();

  @override
  String toString() {
    return 'BillsListState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ListInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _ListInitial implements BillsListState {
  const factory _ListInitial() = _$ListInitialImpl;
}

/// @nodoc
abstract class _$$ListLoadingImplCopyWith<$Res> {
  factory _$$ListLoadingImplCopyWith(
          _$ListLoadingImpl value, $Res Function(_$ListLoadingImpl) then) =
      __$$ListLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ListLoadingImplCopyWithImpl<$Res>
    extends _$BillsListStateCopyWithImpl<$Res, _$ListLoadingImpl>
    implements _$$ListLoadingImplCopyWith<$Res> {
  __$$ListLoadingImplCopyWithImpl(
      _$ListLoadingImpl _value, $Res Function(_$ListLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ListLoadingImpl implements _ListLoading {
  const _$ListLoadingImpl();

  @override
  String toString() {
    return 'BillsListState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ListLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _ListLoading implements BillsListState {
  const factory _ListLoading() = _$ListLoadingImpl;
}

/// @nodoc
abstract class _$$ListLoadedImplCopyWith<$Res> {
  factory _$$ListLoadedImplCopyWith(
          _$ListLoadedImpl value, $Res Function(_$ListLoadedImpl) then) =
      __$$ListLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<BillStatus> billStatuses,
      String? filter,
      BillFrequency? frequencyFilter,
      String? categoryFilter});
}

/// @nodoc
class __$$ListLoadedImplCopyWithImpl<$Res>
    extends _$BillsListStateCopyWithImpl<$Res, _$ListLoadedImpl>
    implements _$$ListLoadedImplCopyWith<$Res> {
  __$$ListLoadedImplCopyWithImpl(
      _$ListLoadedImpl _value, $Res Function(_$ListLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? billStatuses = null,
    Object? filter = freezed,
    Object? frequencyFilter = freezed,
    Object? categoryFilter = freezed,
  }) {
    return _then(_$ListLoadedImpl(
      billStatuses: null == billStatuses
          ? _value._billStatuses
          : billStatuses // ignore: cast_nullable_to_non_nullable
              as List<BillStatus>,
      filter: freezed == filter
          ? _value.filter
          : filter // ignore: cast_nullable_to_non_nullable
              as String?,
      frequencyFilter: freezed == frequencyFilter
          ? _value.frequencyFilter
          : frequencyFilter // ignore: cast_nullable_to_non_nullable
              as BillFrequency?,
      categoryFilter: freezed == categoryFilter
          ? _value.categoryFilter
          : categoryFilter // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ListLoadedImpl implements _ListLoaded {
  const _$ListLoadedImpl(
      {required final List<BillStatus> billStatuses,
      this.filter,
      this.frequencyFilter,
      this.categoryFilter})
      : _billStatuses = billStatuses;

  final List<BillStatus> _billStatuses;
  @override
  List<BillStatus> get billStatuses {
    if (_billStatuses is EqualUnmodifiableListView) return _billStatuses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_billStatuses);
  }

  @override
  final String? filter;
  @override
  final BillFrequency? frequencyFilter;
  @override
  final String? categoryFilter;

  @override
  String toString() {
    return 'BillsListState.loaded(billStatuses: $billStatuses, filter: $filter, frequencyFilter: $frequencyFilter, categoryFilter: $categoryFilter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._billStatuses, _billStatuses) &&
            (identical(other.filter, filter) || other.filter == filter) &&
            (identical(other.frequencyFilter, frequencyFilter) ||
                other.frequencyFilter == frequencyFilter) &&
            (identical(other.categoryFilter, categoryFilter) ||
                other.categoryFilter == categoryFilter));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_billStatuses),
      filter,
      frequencyFilter,
      categoryFilter);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListLoadedImplCopyWith<_$ListLoadedImpl> get copyWith =>
      __$$ListLoadedImplCopyWithImpl<_$ListLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return loaded(billStatuses, filter, frequencyFilter, categoryFilter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return loaded?.call(billStatuses, filter, frequencyFilter, categoryFilter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(billStatuses, filter, frequencyFilter, categoryFilter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _ListLoaded implements BillsListState {
  const factory _ListLoaded(
      {required final List<BillStatus> billStatuses,
      final String? filter,
      final BillFrequency? frequencyFilter,
      final String? categoryFilter}) = _$ListLoadedImpl;

  List<BillStatus> get billStatuses;
  String? get filter;
  BillFrequency? get frequencyFilter;
  String? get categoryFilter;
  @JsonKey(ignore: true)
  _$$ListLoadedImplCopyWith<_$ListLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListErrorImplCopyWith<$Res> {
  factory _$$ListErrorImplCopyWith(
          _$ListErrorImpl value, $Res Function(_$ListErrorImpl) then) =
      __$$ListErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ListErrorImplCopyWithImpl<$Res>
    extends _$BillsListStateCopyWithImpl<$Res, _$ListErrorImpl>
    implements _$$ListErrorImplCopyWith<$Res> {
  __$$ListErrorImplCopyWithImpl(
      _$ListErrorImpl _value, $Res Function(_$ListErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ListErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ListErrorImpl implements _ListError {
  const _$ListErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'BillsListState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListErrorImplCopyWith<_$ListErrorImpl> get copyWith =>
      __$$ListErrorImplCopyWithImpl<_$ListErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ListError implements BillsListState {
  const factory _ListError({required final String message}) = _$ListErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$ListErrorImplCopyWith<_$ListErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListEmptyImplCopyWith<$Res> {
  factory _$$ListEmptyImplCopyWith(
          _$ListEmptyImpl value, $Res Function(_$ListEmptyImpl) then) =
      __$$ListEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ListEmptyImplCopyWithImpl<$Res>
    extends _$BillsListStateCopyWithImpl<$Res, _$ListEmptyImpl>
    implements _$$ListEmptyImplCopyWith<$Res> {
  __$$ListEmptyImplCopyWithImpl(
      _$ListEmptyImpl _value, $Res Function(_$ListEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ListEmptyImpl implements _ListEmpty {
  const _$ListEmptyImpl();

  @override
  String toString() {
    return 'BillsListState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ListEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<BillStatus> billStatuses, String? filter,
            BillFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _ListEmpty implements BillsListState {
  const factory _ListEmpty() = _$ListEmptyImpl;
}

/// @nodoc
mixin _$BillPaymentState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(Bill bill, BillPayment payment) success,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(Bill bill, BillPayment payment)? success,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(Bill bill, BillPayment payment)? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PaymentInitial value) initial,
    required TResult Function(_PaymentProcessing value) processing,
    required TResult Function(_PaymentSuccess value) success,
    required TResult Function(_PaymentError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PaymentInitial value)? initial,
    TResult? Function(_PaymentProcessing value)? processing,
    TResult? Function(_PaymentSuccess value)? success,
    TResult? Function(_PaymentError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PaymentInitial value)? initial,
    TResult Function(_PaymentProcessing value)? processing,
    TResult Function(_PaymentSuccess value)? success,
    TResult Function(_PaymentError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $BillPaymentStateCopyWith<$Res> {
  factory $BillPaymentStateCopyWith(
          BillPaymentState value, $Res Function(BillPaymentState) then) =
      _$BillPaymentStateCopyWithImpl<$Res, BillPaymentState>;
}

/// @nodoc
class _$BillPaymentStateCopyWithImpl<$Res, $Val extends BillPaymentState>
    implements $BillPaymentStateCopyWith<$Res> {
  _$BillPaymentStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$PaymentInitialImplCopyWith<$Res> {
  factory _$$PaymentInitialImplCopyWith(_$PaymentInitialImpl value,
          $Res Function(_$PaymentInitialImpl) then) =
      __$$PaymentInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentInitialImplCopyWithImpl<$Res>
    extends _$BillPaymentStateCopyWithImpl<$Res, _$PaymentInitialImpl>
    implements _$$PaymentInitialImplCopyWith<$Res> {
  __$$PaymentInitialImplCopyWithImpl(
      _$PaymentInitialImpl _value, $Res Function(_$PaymentInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentInitialImpl implements _PaymentInitial {
  const _$PaymentInitialImpl();

  @override
  String toString() {
    return 'BillPaymentState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(Bill bill, BillPayment payment) success,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(Bill bill, BillPayment payment)? success,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(Bill bill, BillPayment payment)? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PaymentInitial value) initial,
    required TResult Function(_PaymentProcessing value) processing,
    required TResult Function(_PaymentSuccess value) success,
    required TResult Function(_PaymentError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PaymentInitial value)? initial,
    TResult? Function(_PaymentProcessing value)? processing,
    TResult? Function(_PaymentSuccess value)? success,
    TResult? Function(_PaymentError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PaymentInitial value)? initial,
    TResult Function(_PaymentProcessing value)? processing,
    TResult Function(_PaymentSuccess value)? success,
    TResult Function(_PaymentError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _PaymentInitial implements BillPaymentState {
  const factory _PaymentInitial() = _$PaymentInitialImpl;
}

/// @nodoc
abstract class _$$PaymentProcessingImplCopyWith<$Res> {
  factory _$$PaymentProcessingImplCopyWith(_$PaymentProcessingImpl value,
          $Res Function(_$PaymentProcessingImpl) then) =
      __$$PaymentProcessingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$PaymentProcessingImplCopyWithImpl<$Res>
    extends _$BillPaymentStateCopyWithImpl<$Res, _$PaymentProcessingImpl>
    implements _$$PaymentProcessingImplCopyWith<$Res> {
  __$$PaymentProcessingImplCopyWithImpl(_$PaymentProcessingImpl _value,
      $Res Function(_$PaymentProcessingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$PaymentProcessingImpl implements _PaymentProcessing {
  const _$PaymentProcessingImpl();

  @override
  String toString() {
    return 'BillPaymentState.processing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$PaymentProcessingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(Bill bill, BillPayment payment) success,
    required TResult Function(String message) error,
  }) {
    return processing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(Bill bill, BillPayment payment)? success,
    TResult? Function(String message)? error,
  }) {
    return processing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(Bill bill, BillPayment payment)? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PaymentInitial value) initial,
    required TResult Function(_PaymentProcessing value) processing,
    required TResult Function(_PaymentSuccess value) success,
    required TResult Function(_PaymentError value) error,
  }) {
    return processing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PaymentInitial value)? initial,
    TResult? Function(_PaymentProcessing value)? processing,
    TResult? Function(_PaymentSuccess value)? success,
    TResult? Function(_PaymentError value)? error,
  }) {
    return processing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PaymentInitial value)? initial,
    TResult Function(_PaymentProcessing value)? processing,
    TResult Function(_PaymentSuccess value)? success,
    TResult Function(_PaymentError value)? error,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing(this);
    }
    return orElse();
  }
}

abstract class _PaymentProcessing implements BillPaymentState {
  const factory _PaymentProcessing() = _$PaymentProcessingImpl;
}

/// @nodoc
abstract class _$$PaymentSuccessImplCopyWith<$Res> {
  factory _$$PaymentSuccessImplCopyWith(_$PaymentSuccessImpl value,
          $Res Function(_$PaymentSuccessImpl) then) =
      __$$PaymentSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({Bill bill, BillPayment payment});

  $BillCopyWith<$Res> get bill;
  $BillPaymentCopyWith<$Res> get payment;
}

/// @nodoc
class __$$PaymentSuccessImplCopyWithImpl<$Res>
    extends _$BillPaymentStateCopyWithImpl<$Res, _$PaymentSuccessImpl>
    implements _$$PaymentSuccessImplCopyWith<$Res> {
  __$$PaymentSuccessImplCopyWithImpl(
      _$PaymentSuccessImpl _value, $Res Function(_$PaymentSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? bill = null,
    Object? payment = null,
  }) {
    return _then(_$PaymentSuccessImpl(
      bill: null == bill
          ? _value.bill
          : bill // ignore: cast_nullable_to_non_nullable
              as Bill,
      payment: null == payment
          ? _value.payment
          : payment // ignore: cast_nullable_to_non_nullable
              as BillPayment,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $BillCopyWith<$Res> get bill {
    return $BillCopyWith<$Res>(_value.bill, (value) {
      return _then(_value.copyWith(bill: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $BillPaymentCopyWith<$Res> get payment {
    return $BillPaymentCopyWith<$Res>(_value.payment, (value) {
      return _then(_value.copyWith(payment: value));
    });
  }
}

/// @nodoc

class _$PaymentSuccessImpl implements _PaymentSuccess {
  const _$PaymentSuccessImpl({required this.bill, required this.payment});

  @override
  final Bill bill;
  @override
  final BillPayment payment;

  @override
  String toString() {
    return 'BillPaymentState.success(bill: $bill, payment: $payment)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentSuccessImpl &&
            (identical(other.bill, bill) || other.bill == bill) &&
            (identical(other.payment, payment) || other.payment == payment));
  }

  @override
  int get hashCode => Object.hash(runtimeType, bill, payment);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentSuccessImplCopyWith<_$PaymentSuccessImpl> get copyWith =>
      __$$PaymentSuccessImplCopyWithImpl<_$PaymentSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(Bill bill, BillPayment payment) success,
    required TResult Function(String message) error,
  }) {
    return success(bill, payment);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(Bill bill, BillPayment payment)? success,
    TResult? Function(String message)? error,
  }) {
    return success?.call(bill, payment);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(Bill bill, BillPayment payment)? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(bill, payment);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PaymentInitial value) initial,
    required TResult Function(_PaymentProcessing value) processing,
    required TResult Function(_PaymentSuccess value) success,
    required TResult Function(_PaymentError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PaymentInitial value)? initial,
    TResult? Function(_PaymentProcessing value)? processing,
    TResult? Function(_PaymentSuccess value)? success,
    TResult? Function(_PaymentError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PaymentInitial value)? initial,
    TResult Function(_PaymentProcessing value)? processing,
    TResult Function(_PaymentSuccess value)? success,
    TResult Function(_PaymentError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _PaymentSuccess implements BillPaymentState {
  const factory _PaymentSuccess(
      {required final Bill bill,
      required final BillPayment payment}) = _$PaymentSuccessImpl;

  Bill get bill;
  BillPayment get payment;
  @JsonKey(ignore: true)
  _$$PaymentSuccessImplCopyWith<_$PaymentSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$PaymentErrorImplCopyWith<$Res> {
  factory _$$PaymentErrorImplCopyWith(
          _$PaymentErrorImpl value, $Res Function(_$PaymentErrorImpl) then) =
      __$$PaymentErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$PaymentErrorImplCopyWithImpl<$Res>
    extends _$BillPaymentStateCopyWithImpl<$Res, _$PaymentErrorImpl>
    implements _$$PaymentErrorImplCopyWith<$Res> {
  __$$PaymentErrorImplCopyWithImpl(
      _$PaymentErrorImpl _value, $Res Function(_$PaymentErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$PaymentErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$PaymentErrorImpl implements _PaymentError {
  const _$PaymentErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'BillPaymentState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$PaymentErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$PaymentErrorImplCopyWith<_$PaymentErrorImpl> get copyWith =>
      __$$PaymentErrorImplCopyWithImpl<_$PaymentErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(Bill bill, BillPayment payment) success,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(Bill bill, BillPayment payment)? success,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(Bill bill, BillPayment payment)? success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_PaymentInitial value) initial,
    required TResult Function(_PaymentProcessing value) processing,
    required TResult Function(_PaymentSuccess value) success,
    required TResult Function(_PaymentError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_PaymentInitial value)? initial,
    TResult? Function(_PaymentProcessing value)? processing,
    TResult? Function(_PaymentSuccess value)? success,
    TResult? Function(_PaymentError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_PaymentInitial value)? initial,
    TResult Function(_PaymentProcessing value)? processing,
    TResult Function(_PaymentSuccess value)? success,
    TResult Function(_PaymentError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _PaymentError implements BillPaymentState {
  const factory _PaymentError({required final String message}) =
      _$PaymentErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$PaymentErrorImplCopyWith<_$PaymentErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
