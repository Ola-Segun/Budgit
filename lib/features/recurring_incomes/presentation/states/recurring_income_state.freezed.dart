// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: type=lint
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target, unnecessary_question_mark

part of 'recurring_income_state.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more information: https://github.com/rrousselGit/freezed#adding-getters-and-methods-to-our-models');

/// @nodoc
mixin _$RecurringIncomeState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecurringIncomeStateCopyWith<$Res> {
  factory $RecurringIncomeStateCopyWith(RecurringIncomeState value,
          $Res Function(RecurringIncomeState) then) =
      _$RecurringIncomeStateCopyWithImpl<$Res, RecurringIncomeState>;
}

/// @nodoc
class _$RecurringIncomeStateCopyWithImpl<$Res,
        $Val extends RecurringIncomeState>
    implements $RecurringIncomeStateCopyWith<$Res> {
  _$RecurringIncomeStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$InitialImplCopyWith<$Res> {
  factory _$$InitialImplCopyWith(
          _$InitialImpl value, $Res Function(_$InitialImpl) then) =
      __$$InitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$InitialImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$InitialImpl>
    implements _$$InitialImplCopyWith<$Res> {
  __$$InitialImplCopyWithImpl(
      _$InitialImpl _value, $Res Function(_$InitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$InitialImpl implements _Initial {
  const _$InitialImpl();

  @override
  String toString() {
    return 'RecurringIncomeState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$InitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _Initial implements RecurringIncomeState {
  const factory _Initial() = _$InitialImpl;
}

/// @nodoc
abstract class _$$LoadingImplCopyWith<$Res> {
  factory _$$LoadingImplCopyWith(
          _$LoadingImpl value, $Res Function(_$LoadingImpl) then) =
      __$$LoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$LoadingImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$LoadingImpl>
    implements _$$LoadingImplCopyWith<$Res> {
  __$$LoadingImplCopyWithImpl(
      _$LoadingImpl _value, $Res Function(_$LoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$LoadingImpl implements _Loading {
  const _$LoadingImpl();

  @override
  String toString() {
    return 'RecurringIncomeState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$LoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _Loading implements RecurringIncomeState {
  const factory _Loading() = _$LoadingImpl;
}

/// @nodoc
abstract class _$$LoadedImplCopyWith<$Res> {
  factory _$$LoadedImplCopyWith(
          _$LoadedImpl value, $Res Function(_$LoadedImpl) then) =
      __$$LoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({List<RecurringIncome> incomes, RecurringIncomesSummary summary});

  $RecurringIncomesSummaryCopyWith<$Res> get summary;
}

/// @nodoc
class __$$LoadedImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$LoadedImpl>
    implements _$$LoadedImplCopyWith<$Res> {
  __$$LoadedImplCopyWithImpl(
      _$LoadedImpl _value, $Res Function(_$LoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? incomes = null,
    Object? summary = null,
  }) {
    return _then(_$LoadedImpl(
      incomes: null == incomes
          ? _value._incomes
          : incomes // ignore: cast_nullable_to_non_nullable
              as List<RecurringIncome>,
      summary: null == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as RecurringIncomesSummary,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomesSummaryCopyWith<$Res> get summary {
    return $RecurringIncomesSummaryCopyWith<$Res>(_value.summary, (value) {
      return _then(_value.copyWith(summary: value));
    });
  }
}

/// @nodoc

class _$LoadedImpl implements _Loaded {
  const _$LoadedImpl(
      {required final List<RecurringIncome> incomes, required this.summary})
      : _incomes = incomes;

  final List<RecurringIncome> _incomes;
  @override
  List<RecurringIncome> get incomes {
    if (_incomes is EqualUnmodifiableListView) return _incomes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_incomes);
  }

  @override
  final RecurringIncomesSummary summary;

  @override
  String toString() {
    return 'RecurringIncomeState.loaded(incomes: $incomes, summary: $summary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$LoadedImpl &&
            const DeepCollectionEquality().equals(other._incomes, _incomes) &&
            (identical(other.summary, summary) || other.summary == summary));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, const DeepCollectionEquality().hash(_incomes), summary);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      __$$LoadedImplCopyWithImpl<_$LoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return loaded(incomes, summary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return loaded?.call(incomes, summary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(incomes, summary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _Loaded implements RecurringIncomeState {
  const factory _Loaded(
      {required final List<RecurringIncome> incomes,
      required final RecurringIncomesSummary summary}) = _$LoadedImpl;

  List<RecurringIncome> get incomes;
  RecurringIncomesSummary get summary;
  @JsonKey(ignore: true)
  _$$LoadedImplCopyWith<_$LoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ErrorImplCopyWith<$Res> {
  factory _$$ErrorImplCopyWith(
          _$ErrorImpl value, $Res Function(_$ErrorImpl) then) =
      __$$ErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {String message,
      List<RecurringIncome>? incomes,
      RecurringIncomesSummary? summary});

  $RecurringIncomesSummaryCopyWith<$Res>? get summary;
}

/// @nodoc
class __$$ErrorImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$ErrorImpl>
    implements _$$ErrorImplCopyWith<$Res> {
  __$$ErrorImplCopyWithImpl(
      _$ErrorImpl _value, $Res Function(_$ErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? incomes = freezed,
    Object? summary = freezed,
  }) {
    return _then(_$ErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      incomes: freezed == incomes
          ? _value._incomes
          : incomes // ignore: cast_nullable_to_non_nullable
              as List<RecurringIncome>?,
      summary: freezed == summary
          ? _value.summary
          : summary // ignore: cast_nullable_to_non_nullable
              as RecurringIncomesSummary?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomesSummaryCopyWith<$Res>? get summary {
    if (_value.summary == null) {
      return null;
    }

    return $RecurringIncomesSummaryCopyWith<$Res>(_value.summary!, (value) {
      return _then(_value.copyWith(summary: value));
    });
  }
}

/// @nodoc

class _$ErrorImpl implements _Error {
  const _$ErrorImpl(
      {required this.message,
      final List<RecurringIncome>? incomes,
      this.summary})
      : _incomes = incomes;

  @override
  final String message;
  final List<RecurringIncome>? _incomes;
  @override
  List<RecurringIncome>? get incomes {
    final value = _incomes;
    if (value == null) return null;
    if (_incomes is EqualUnmodifiableListView) return _incomes;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(value);
  }

  @override
  final RecurringIncomesSummary? summary;

  @override
  String toString() {
    return 'RecurringIncomeState.error(message: $message, incomes: $incomes, summary: $summary)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._incomes, _incomes) &&
            (identical(other.summary, summary) || other.summary == summary));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message,
      const DeepCollectionEquality().hash(_incomes), summary);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      __$$ErrorImplCopyWithImpl<_$ErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return error(message, incomes, summary);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return error?.call(message, incomes, summary);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, incomes, summary);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _Error implements RecurringIncomeState {
  const factory _Error(
      {required final String message,
      final List<RecurringIncome>? incomes,
      final RecurringIncomesSummary? summary}) = _$ErrorImpl;

  String get message;
  List<RecurringIncome>? get incomes;
  RecurringIncomesSummary? get summary;
  @JsonKey(ignore: true)
  _$$ErrorImplCopyWith<_$ErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IncomeLoadedImplCopyWith<$Res> {
  factory _$$IncomeLoadedImplCopyWith(
          _$IncomeLoadedImpl value, $Res Function(_$IncomeLoadedImpl) then) =
      __$$IncomeLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome income, RecurringIncomeStatus status});

  $RecurringIncomeCopyWith<$Res> get income;
  $RecurringIncomeStatusCopyWith<$Res> get status;
}

/// @nodoc
class __$$IncomeLoadedImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$IncomeLoadedImpl>
    implements _$$IncomeLoadedImplCopyWith<$Res> {
  __$$IncomeLoadedImplCopyWithImpl(
      _$IncomeLoadedImpl _value, $Res Function(_$IncomeLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
    Object? status = null,
  }) {
    return _then(_$IncomeLoadedImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome,
      status: null == status
          ? _value.status
          : status // ignore: cast_nullable_to_non_nullable
              as RecurringIncomeStatus,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res> get income {
    return $RecurringIncomeCopyWith<$Res>(_value.income, (value) {
      return _then(_value.copyWith(income: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeStatusCopyWith<$Res> get status {
    return $RecurringIncomeStatusCopyWith<$Res>(_value.status, (value) {
      return _then(_value.copyWith(status: value));
    });
  }
}

/// @nodoc

class _$IncomeLoadedImpl implements _IncomeLoaded {
  const _$IncomeLoadedImpl({required this.income, required this.status});

  @override
  final RecurringIncome income;
  @override
  final RecurringIncomeStatus status;

  @override
  String toString() {
    return 'RecurringIncomeState.incomeLoaded(income: $income, status: $status)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IncomeLoadedImpl &&
            (identical(other.income, income) || other.income == income) &&
            (identical(other.status, status) || other.status == status));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income, status);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IncomeLoadedImplCopyWith<_$IncomeLoadedImpl> get copyWith =>
      __$$IncomeLoadedImplCopyWithImpl<_$IncomeLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return incomeLoaded(income, status);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return incomeLoaded?.call(income, status);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (incomeLoaded != null) {
      return incomeLoaded(income, status);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return incomeLoaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return incomeLoaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (incomeLoaded != null) {
      return incomeLoaded(this);
    }
    return orElse();
  }
}

abstract class _IncomeLoaded implements RecurringIncomeState {
  const factory _IncomeLoaded(
      {required final RecurringIncome income,
      required final RecurringIncomeStatus status}) = _$IncomeLoadedImpl;

  RecurringIncome get income;
  RecurringIncomeStatus get status;
  @JsonKey(ignore: true)
  _$$IncomeLoadedImplCopyWith<_$IncomeLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IncomeSavedImplCopyWith<$Res> {
  factory _$$IncomeSavedImplCopyWith(
          _$IncomeSavedImpl value, $Res Function(_$IncomeSavedImpl) then) =
      __$$IncomeSavedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome income});

  $RecurringIncomeCopyWith<$Res> get income;
}

/// @nodoc
class __$$IncomeSavedImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$IncomeSavedImpl>
    implements _$$IncomeSavedImplCopyWith<$Res> {
  __$$IncomeSavedImplCopyWithImpl(
      _$IncomeSavedImpl _value, $Res Function(_$IncomeSavedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
  }) {
    return _then(_$IncomeSavedImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res> get income {
    return $RecurringIncomeCopyWith<$Res>(_value.income, (value) {
      return _then(_value.copyWith(income: value));
    });
  }
}

/// @nodoc

class _$IncomeSavedImpl implements _IncomeSaved {
  const _$IncomeSavedImpl({required this.income});

  @override
  final RecurringIncome income;

  @override
  String toString() {
    return 'RecurringIncomeState.incomeSaved(income: $income)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$IncomeSavedImpl &&
            (identical(other.income, income) || other.income == income));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$IncomeSavedImplCopyWith<_$IncomeSavedImpl> get copyWith =>
      __$$IncomeSavedImplCopyWithImpl<_$IncomeSavedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return incomeSaved(income);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return incomeSaved?.call(income);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (incomeSaved != null) {
      return incomeSaved(income);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return incomeSaved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return incomeSaved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (incomeSaved != null) {
      return incomeSaved(this);
    }
    return orElse();
  }
}

abstract class _IncomeSaved implements RecurringIncomeState {
  const factory _IncomeSaved({required final RecurringIncome income}) =
      _$IncomeSavedImpl;

  RecurringIncome get income;
  @JsonKey(ignore: true)
  _$$IncomeSavedImplCopyWith<_$IncomeSavedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$IncomeDeletedImplCopyWith<$Res> {
  factory _$$IncomeDeletedImplCopyWith(
          _$IncomeDeletedImpl value, $Res Function(_$IncomeDeletedImpl) then) =
      __$$IncomeDeletedImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$IncomeDeletedImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$IncomeDeletedImpl>
    implements _$$IncomeDeletedImplCopyWith<$Res> {
  __$$IncomeDeletedImplCopyWithImpl(
      _$IncomeDeletedImpl _value, $Res Function(_$IncomeDeletedImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$IncomeDeletedImpl implements _IncomeDeleted {
  const _$IncomeDeletedImpl();

  @override
  String toString() {
    return 'RecurringIncomeState.incomeDeleted()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$IncomeDeletedImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return incomeDeleted();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return incomeDeleted?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (incomeDeleted != null) {
      return incomeDeleted();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return incomeDeleted(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return incomeDeleted?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (incomeDeleted != null) {
      return incomeDeleted(this);
    }
    return orElse();
  }
}

abstract class _IncomeDeleted implements RecurringIncomeState {
  const factory _IncomeDeleted() = _$IncomeDeletedImpl;
}

/// @nodoc
abstract class _$$ReceiptRecordedImplCopyWith<$Res> {
  factory _$$ReceiptRecordedImplCopyWith(_$ReceiptRecordedImpl value,
          $Res Function(_$ReceiptRecordedImpl) then) =
      __$$ReceiptRecordedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome income});

  $RecurringIncomeCopyWith<$Res> get income;
}

/// @nodoc
class __$$ReceiptRecordedImplCopyWithImpl<$Res>
    extends _$RecurringIncomeStateCopyWithImpl<$Res, _$ReceiptRecordedImpl>
    implements _$$ReceiptRecordedImplCopyWith<$Res> {
  __$$ReceiptRecordedImplCopyWithImpl(
      _$ReceiptRecordedImpl _value, $Res Function(_$ReceiptRecordedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
  }) {
    return _then(_$ReceiptRecordedImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res> get income {
    return $RecurringIncomeCopyWith<$Res>(_value.income, (value) {
      return _then(_value.copyWith(income: value));
    });
  }
}

/// @nodoc

class _$ReceiptRecordedImpl implements _ReceiptRecorded {
  const _$ReceiptRecordedImpl({required this.income});

  @override
  final RecurringIncome income;

  @override
  String toString() {
    return 'RecurringIncomeState.receiptRecorded(income: $income)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReceiptRecordedImpl &&
            (identical(other.income, income) || other.income == income));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReceiptRecordedImplCopyWith<_$ReceiptRecordedImpl> get copyWith =>
      __$$ReceiptRecordedImplCopyWithImpl<_$ReceiptRecordedImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)
        loaded,
    required TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)
        error,
    required TResult Function(
            RecurringIncome income, RecurringIncomeStatus status)
        incomeLoaded,
    required TResult Function(RecurringIncome income) incomeSaved,
    required TResult Function() incomeDeleted,
    required TResult Function(RecurringIncome income) receiptRecorded,
  }) {
    return receiptRecorded(income);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult? Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult? Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult? Function(RecurringIncome income)? incomeSaved,
    TResult? Function()? incomeDeleted,
    TResult? Function(RecurringIncome income)? receiptRecorded,
  }) {
    return receiptRecorded?.call(income);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(
            List<RecurringIncome> incomes, RecurringIncomesSummary summary)?
        loaded,
    TResult Function(String message, List<RecurringIncome>? incomes,
            RecurringIncomesSummary? summary)?
        error,
    TResult Function(RecurringIncome income, RecurringIncomeStatus status)?
        incomeLoaded,
    TResult Function(RecurringIncome income)? incomeSaved,
    TResult Function()? incomeDeleted,
    TResult Function(RecurringIncome income)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (receiptRecorded != null) {
      return receiptRecorded(income);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_Initial value) initial,
    required TResult Function(_Loading value) loading,
    required TResult Function(_Loaded value) loaded,
    required TResult Function(_Error value) error,
    required TResult Function(_IncomeLoaded value) incomeLoaded,
    required TResult Function(_IncomeSaved value) incomeSaved,
    required TResult Function(_IncomeDeleted value) incomeDeleted,
    required TResult Function(_ReceiptRecorded value) receiptRecorded,
  }) {
    return receiptRecorded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_Initial value)? initial,
    TResult? Function(_Loading value)? loading,
    TResult? Function(_Loaded value)? loaded,
    TResult? Function(_Error value)? error,
    TResult? Function(_IncomeLoaded value)? incomeLoaded,
    TResult? Function(_IncomeSaved value)? incomeSaved,
    TResult? Function(_IncomeDeleted value)? incomeDeleted,
    TResult? Function(_ReceiptRecorded value)? receiptRecorded,
  }) {
    return receiptRecorded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_Initial value)? initial,
    TResult Function(_Loading value)? loading,
    TResult Function(_Loaded value)? loaded,
    TResult Function(_Error value)? error,
    TResult Function(_IncomeLoaded value)? incomeLoaded,
    TResult Function(_IncomeSaved value)? incomeSaved,
    TResult Function(_IncomeDeleted value)? incomeDeleted,
    TResult Function(_ReceiptRecorded value)? receiptRecorded,
    required TResult orElse(),
  }) {
    if (receiptRecorded != null) {
      return receiptRecorded(this);
    }
    return orElse();
  }
}

abstract class _ReceiptRecorded implements RecurringIncomeState {
  const factory _ReceiptRecorded({required final RecurringIncome income}) =
      _$ReceiptRecordedImpl;

  RecurringIncome get income;
  @JsonKey(ignore: true)
  _$$ReceiptRecordedImplCopyWith<_$ReceiptRecordedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RecurringIncomeFormState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecurringIncomeFormStateCopyWith<$Res> {
  factory $RecurringIncomeFormStateCopyWith(RecurringIncomeFormState value,
          $Res Function(RecurringIncomeFormState) then) =
      _$RecurringIncomeFormStateCopyWithImpl<$Res, RecurringIncomeFormState>;
}

/// @nodoc
class _$RecurringIncomeFormStateCopyWithImpl<$Res,
        $Val extends RecurringIncomeFormState>
    implements $RecurringIncomeFormStateCopyWith<$Res> {
  _$RecurringIncomeFormStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$FormInitialImplCopyWith<$Res> {
  factory _$$FormInitialImplCopyWith(
          _$FormInitialImpl value, $Res Function(_$FormInitialImpl) then) =
      __$$FormInitialImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome? income});

  $RecurringIncomeCopyWith<$Res>? get income;
}

/// @nodoc
class __$$FormInitialImplCopyWithImpl<$Res>
    extends _$RecurringIncomeFormStateCopyWithImpl<$Res, _$FormInitialImpl>
    implements _$$FormInitialImplCopyWith<$Res> {
  __$$FormInitialImplCopyWithImpl(
      _$FormInitialImpl _value, $Res Function(_$FormInitialImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = freezed,
  }) {
    return _then(_$FormInitialImpl(
      income: freezed == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome?,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res>? get income {
    if (_value.income == null) {
      return null;
    }

    return $RecurringIncomeCopyWith<$Res>(_value.income!, (value) {
      return _then(_value.copyWith(income: value));
    });
  }
}

/// @nodoc

class _$FormInitialImpl implements _FormInitial {
  const _$FormInitialImpl({this.income});

  @override
  final RecurringIncome? income;

  @override
  String toString() {
    return 'RecurringIncomeFormState.initial(income: $income)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormInitialImpl &&
            (identical(other.income, income) || other.income == income));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormInitialImplCopyWith<_$FormInitialImpl> get copyWith =>
      __$$FormInitialImplCopyWithImpl<_$FormInitialImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) {
    return initial(income);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) {
    return initial?.call(income);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(income);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _FormInitial implements RecurringIncomeFormState {
  const factory _FormInitial({final RecurringIncome? income}) =
      _$FormInitialImpl;

  RecurringIncome? get income;
  @JsonKey(ignore: true)
  _$$FormInitialImplCopyWith<_$FormInitialImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormLoadingImplCopyWith<$Res> {
  factory _$$FormLoadingImplCopyWith(
          _$FormLoadingImpl value, $Res Function(_$FormLoadingImpl) then) =
      __$$FormLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FormLoadingImplCopyWithImpl<$Res>
    extends _$RecurringIncomeFormStateCopyWithImpl<$Res, _$FormLoadingImpl>
    implements _$$FormLoadingImplCopyWith<$Res> {
  __$$FormLoadingImplCopyWithImpl(
      _$FormLoadingImpl _value, $Res Function(_$FormLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FormLoadingImpl implements _FormLoading {
  const _$FormLoadingImpl();

  @override
  String toString() {
    return 'RecurringIncomeFormState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FormLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _FormLoading implements RecurringIncomeFormState {
  const factory _FormLoading() = _$FormLoadingImpl;
}

/// @nodoc
abstract class _$$FormSavedImplCopyWith<$Res> {
  factory _$$FormSavedImplCopyWith(
          _$FormSavedImpl value, $Res Function(_$FormSavedImpl) then) =
      __$$FormSavedImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome income});

  $RecurringIncomeCopyWith<$Res> get income;
}

/// @nodoc
class __$$FormSavedImplCopyWithImpl<$Res>
    extends _$RecurringIncomeFormStateCopyWithImpl<$Res, _$FormSavedImpl>
    implements _$$FormSavedImplCopyWith<$Res> {
  __$$FormSavedImplCopyWithImpl(
      _$FormSavedImpl _value, $Res Function(_$FormSavedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
  }) {
    return _then(_$FormSavedImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res> get income {
    return $RecurringIncomeCopyWith<$Res>(_value.income, (value) {
      return _then(_value.copyWith(income: value));
    });
  }
}

/// @nodoc

class _$FormSavedImpl implements _FormSaved {
  const _$FormSavedImpl({required this.income});

  @override
  final RecurringIncome income;

  @override
  String toString() {
    return 'RecurringIncomeFormState.saved(income: $income)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormSavedImpl &&
            (identical(other.income, income) || other.income == income));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormSavedImplCopyWith<_$FormSavedImpl> get copyWith =>
      __$$FormSavedImplCopyWithImpl<_$FormSavedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) {
    return saved(income);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) {
    return saved?.call(income);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(income);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return saved(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return saved?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (saved != null) {
      return saved(this);
    }
    return orElse();
  }
}

abstract class _FormSaved implements RecurringIncomeFormState {
  const factory _FormSaved({required final RecurringIncome income}) =
      _$FormSavedImpl;

  RecurringIncome get income;
  @JsonKey(ignore: true)
  _$$FormSavedImplCopyWith<_$FormSavedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormErrorImplCopyWith<$Res> {
  factory _$$FormErrorImplCopyWith(
          _$FormErrorImpl value, $Res Function(_$FormErrorImpl) then) =
      __$$FormErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message, Map<String, String> errors});
}

/// @nodoc
class __$$FormErrorImplCopyWithImpl<$Res>
    extends _$RecurringIncomeFormStateCopyWithImpl<$Res, _$FormErrorImpl>
    implements _$$FormErrorImplCopyWith<$Res> {
  __$$FormErrorImplCopyWithImpl(
      _$FormErrorImpl _value, $Res Function(_$FormErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
    Object? errors = null,
  }) {
    return _then(_$FormErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
      errors: null == errors
          ? _value._errors
          : errors // ignore: cast_nullable_to_non_nullable
              as Map<String, String>,
    ));
  }
}

/// @nodoc

class _$FormErrorImpl implements _FormError {
  const _$FormErrorImpl(
      {required this.message, required final Map<String, String> errors})
      : _errors = errors;

  @override
  final String message;
  final Map<String, String> _errors;
  @override
  Map<String, String> get errors {
    if (_errors is EqualUnmodifiableMapView) return _errors;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableMapView(_errors);
  }

  @override
  String toString() {
    return 'RecurringIncomeFormState.error(message: $message, errors: $errors)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormErrorImpl &&
            (identical(other.message, message) || other.message == message) &&
            const DeepCollectionEquality().equals(other._errors, _errors));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType, message, const DeepCollectionEquality().hash(_errors));

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormErrorImplCopyWith<_$FormErrorImpl> get copyWith =>
      __$$FormErrorImplCopyWithImpl<_$FormErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) {
    return error(message, errors);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) {
    return error?.call(message, errors);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message, errors);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _FormError implements RecurringIncomeFormState {
  const factory _FormError(
      {required final String message,
      required final Map<String, String> errors}) = _$FormErrorImpl;

  String get message;
  Map<String, String> get errors;
  @JsonKey(ignore: true)
  _$$FormErrorImplCopyWith<_$FormErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$FormValidatingImplCopyWith<$Res> {
  factory _$$FormValidatingImplCopyWith(_$FormValidatingImpl value,
          $Res Function(_$FormValidatingImpl) then) =
      __$$FormValidatingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$FormValidatingImplCopyWithImpl<$Res>
    extends _$RecurringIncomeFormStateCopyWithImpl<$Res, _$FormValidatingImpl>
    implements _$$FormValidatingImplCopyWith<$Res> {
  __$$FormValidatingImplCopyWithImpl(
      _$FormValidatingImpl _value, $Res Function(_$FormValidatingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$FormValidatingImpl implements _FormValidating {
  const _$FormValidatingImpl();

  @override
  String toString() {
    return 'RecurringIncomeFormState.validating()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$FormValidatingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) {
    return validating();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) {
    return validating?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) {
    if (validating != null) {
      return validating();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return validating(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return validating?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (validating != null) {
      return validating(this);
    }
    return orElse();
  }
}

abstract class _FormValidating implements RecurringIncomeFormState {
  const factory _FormValidating() = _$FormValidatingImpl;
}

/// @nodoc
abstract class _$$FormValidImplCopyWith<$Res> {
  factory _$$FormValidImplCopyWith(
          _$FormValidImpl value, $Res Function(_$FormValidImpl) then) =
      __$$FormValidImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome income});

  $RecurringIncomeCopyWith<$Res> get income;
}

/// @nodoc
class __$$FormValidImplCopyWithImpl<$Res>
    extends _$RecurringIncomeFormStateCopyWithImpl<$Res, _$FormValidImpl>
    implements _$$FormValidImplCopyWith<$Res> {
  __$$FormValidImplCopyWithImpl(
      _$FormValidImpl _value, $Res Function(_$FormValidImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
  }) {
    return _then(_$FormValidImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res> get income {
    return $RecurringIncomeCopyWith<$Res>(_value.income, (value) {
      return _then(_value.copyWith(income: value));
    });
  }
}

/// @nodoc

class _$FormValidImpl implements _FormValid {
  const _$FormValidImpl({required this.income});

  @override
  final RecurringIncome income;

  @override
  String toString() {
    return 'RecurringIncomeFormState.valid(income: $income)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$FormValidImpl &&
            (identical(other.income, income) || other.income == income));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$FormValidImplCopyWith<_$FormValidImpl> get copyWith =>
      __$$FormValidImplCopyWithImpl<_$FormValidImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function(RecurringIncome? income) initial,
    required TResult Function() loading,
    required TResult Function(RecurringIncome income) saved,
    required TResult Function(String message, Map<String, String> errors) error,
    required TResult Function() validating,
    required TResult Function(RecurringIncome income) valid,
  }) {
    return valid(income);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function(RecurringIncome? income)? initial,
    TResult? Function()? loading,
    TResult? Function(RecurringIncome income)? saved,
    TResult? Function(String message, Map<String, String> errors)? error,
    TResult? Function()? validating,
    TResult? Function(RecurringIncome income)? valid,
  }) {
    return valid?.call(income);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function(RecurringIncome? income)? initial,
    TResult Function()? loading,
    TResult Function(RecurringIncome income)? saved,
    TResult Function(String message, Map<String, String> errors)? error,
    TResult Function()? validating,
    TResult Function(RecurringIncome income)? valid,
    required TResult orElse(),
  }) {
    if (valid != null) {
      return valid(income);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_FormInitial value) initial,
    required TResult Function(_FormLoading value) loading,
    required TResult Function(_FormSaved value) saved,
    required TResult Function(_FormError value) error,
    required TResult Function(_FormValidating value) validating,
    required TResult Function(_FormValid value) valid,
  }) {
    return valid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_FormInitial value)? initial,
    TResult? Function(_FormLoading value)? loading,
    TResult? Function(_FormSaved value)? saved,
    TResult? Function(_FormError value)? error,
    TResult? Function(_FormValidating value)? validating,
    TResult? Function(_FormValid value)? valid,
  }) {
    return valid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_FormInitial value)? initial,
    TResult Function(_FormLoading value)? loading,
    TResult Function(_FormSaved value)? saved,
    TResult Function(_FormError value)? error,
    TResult Function(_FormValidating value)? validating,
    TResult Function(_FormValid value)? valid,
    required TResult orElse(),
  }) {
    if (valid != null) {
      return valid(this);
    }
    return orElse();
  }
}

abstract class _FormValid implements RecurringIncomeFormState {
  const factory _FormValid({required final RecurringIncome income}) =
      _$FormValidImpl;

  RecurringIncome get income;
  @JsonKey(ignore: true)
  _$$FormValidImplCopyWith<_$FormValidImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
mixin _$RecurringIncomesListState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<RecurringIncomeStatus> incomeStatuses, String? filter,
            RecurringIncomeFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecurringIncomesListStateCopyWith<$Res> {
  factory $RecurringIncomesListStateCopyWith(RecurringIncomesListState value,
          $Res Function(RecurringIncomesListState) then) =
      _$RecurringIncomesListStateCopyWithImpl<$Res, RecurringIncomesListState>;
}

/// @nodoc
class _$RecurringIncomesListStateCopyWithImpl<$Res,
        $Val extends RecurringIncomesListState>
    implements $RecurringIncomesListStateCopyWith<$Res> {
  _$RecurringIncomesListStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ListInitialImplCopyWith<$Res> {
  factory _$$ListInitialImplCopyWith(
          _$ListInitialImpl value, $Res Function(_$ListInitialImpl) then) =
      __$$ListInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ListInitialImplCopyWithImpl<$Res>
    extends _$RecurringIncomesListStateCopyWithImpl<$Res, _$ListInitialImpl>
    implements _$$ListInitialImplCopyWith<$Res> {
  __$$ListInitialImplCopyWithImpl(
      _$ListInitialImpl _value, $Res Function(_$ListInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ListInitialImpl implements _ListInitial {
  const _$ListInitialImpl();

  @override
  String toString() {
    return 'RecurringIncomesListState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ListInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<RecurringIncomeStatus> incomeStatuses, String? filter,
            RecurringIncomeFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _ListInitial implements RecurringIncomesListState {
  const factory _ListInitial() = _$ListInitialImpl;
}

/// @nodoc
abstract class _$$ListLoadingImplCopyWith<$Res> {
  factory _$$ListLoadingImplCopyWith(
          _$ListLoadingImpl value, $Res Function(_$ListLoadingImpl) then) =
      __$$ListLoadingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ListLoadingImplCopyWithImpl<$Res>
    extends _$RecurringIncomesListStateCopyWithImpl<$Res, _$ListLoadingImpl>
    implements _$$ListLoadingImplCopyWith<$Res> {
  __$$ListLoadingImplCopyWithImpl(
      _$ListLoadingImpl _value, $Res Function(_$ListLoadingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ListLoadingImpl implements _ListLoading {
  const _$ListLoadingImpl();

  @override
  String toString() {
    return 'RecurringIncomesListState.loading()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ListLoadingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return loading();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return loading?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<RecurringIncomeStatus> incomeStatuses, String? filter,
            RecurringIncomeFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return loading(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return loading?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (loading != null) {
      return loading(this);
    }
    return orElse();
  }
}

abstract class _ListLoading implements RecurringIncomesListState {
  const factory _ListLoading() = _$ListLoadingImpl;
}

/// @nodoc
abstract class _$$ListLoadedImplCopyWith<$Res> {
  factory _$$ListLoadedImplCopyWith(
          _$ListLoadedImpl value, $Res Function(_$ListLoadedImpl) then) =
      __$$ListLoadedImplCopyWithImpl<$Res>;
  @useResult
  $Res call(
      {List<RecurringIncomeStatus> incomeStatuses,
      String? filter,
      RecurringIncomeFrequency? frequencyFilter,
      String? categoryFilter});
}

/// @nodoc
class __$$ListLoadedImplCopyWithImpl<$Res>
    extends _$RecurringIncomesListStateCopyWithImpl<$Res, _$ListLoadedImpl>
    implements _$$ListLoadedImplCopyWith<$Res> {
  __$$ListLoadedImplCopyWithImpl(
      _$ListLoadedImpl _value, $Res Function(_$ListLoadedImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? incomeStatuses = null,
    Object? filter = freezed,
    Object? frequencyFilter = freezed,
    Object? categoryFilter = freezed,
  }) {
    return _then(_$ListLoadedImpl(
      incomeStatuses: null == incomeStatuses
          ? _value._incomeStatuses
          : incomeStatuses // ignore: cast_nullable_to_non_nullable
              as List<RecurringIncomeStatus>,
      filter: freezed == filter
          ? _value.filter
          : filter // ignore: cast_nullable_to_non_nullable
              as String?,
      frequencyFilter: freezed == frequencyFilter
          ? _value.frequencyFilter
          : frequencyFilter // ignore: cast_nullable_to_non_nullable
              as RecurringIncomeFrequency?,
      categoryFilter: freezed == categoryFilter
          ? _value.categoryFilter
          : categoryFilter // ignore: cast_nullable_to_non_nullable
              as String?,
    ));
  }
}

/// @nodoc

class _$ListLoadedImpl implements _ListLoaded {
  const _$ListLoadedImpl(
      {required final List<RecurringIncomeStatus> incomeStatuses,
      this.filter,
      this.frequencyFilter,
      this.categoryFilter})
      : _incomeStatuses = incomeStatuses;

  final List<RecurringIncomeStatus> _incomeStatuses;
  @override
  List<RecurringIncomeStatus> get incomeStatuses {
    if (_incomeStatuses is EqualUnmodifiableListView) return _incomeStatuses;
    // ignore: implicit_dynamic_type
    return EqualUnmodifiableListView(_incomeStatuses);
  }

  @override
  final String? filter;
  @override
  final RecurringIncomeFrequency? frequencyFilter;
  @override
  final String? categoryFilter;

  @override
  String toString() {
    return 'RecurringIncomesListState.loaded(incomeStatuses: $incomeStatuses, filter: $filter, frequencyFilter: $frequencyFilter, categoryFilter: $categoryFilter)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListLoadedImpl &&
            const DeepCollectionEquality()
                .equals(other._incomeStatuses, _incomeStatuses) &&
            (identical(other.filter, filter) || other.filter == filter) &&
            (identical(other.frequencyFilter, frequencyFilter) ||
                other.frequencyFilter == frequencyFilter) &&
            (identical(other.categoryFilter, categoryFilter) ||
                other.categoryFilter == categoryFilter));
  }

  @override
  int get hashCode => Object.hash(
      runtimeType,
      const DeepCollectionEquality().hash(_incomeStatuses),
      filter,
      frequencyFilter,
      categoryFilter);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListLoadedImplCopyWith<_$ListLoadedImpl> get copyWith =>
      __$$ListLoadedImplCopyWithImpl<_$ListLoadedImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return loaded(incomeStatuses, filter, frequencyFilter, categoryFilter);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return loaded?.call(
        incomeStatuses, filter, frequencyFilter, categoryFilter);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<RecurringIncomeStatus> incomeStatuses, String? filter,
            RecurringIncomeFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(incomeStatuses, filter, frequencyFilter, categoryFilter);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return loaded(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return loaded?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (loaded != null) {
      return loaded(this);
    }
    return orElse();
  }
}

abstract class _ListLoaded implements RecurringIncomesListState {
  const factory _ListLoaded(
      {required final List<RecurringIncomeStatus> incomeStatuses,
      final String? filter,
      final RecurringIncomeFrequency? frequencyFilter,
      final String? categoryFilter}) = _$ListLoadedImpl;

  List<RecurringIncomeStatus> get incomeStatuses;
  String? get filter;
  RecurringIncomeFrequency? get frequencyFilter;
  String? get categoryFilter;
  @JsonKey(ignore: true)
  _$$ListLoadedImplCopyWith<_$ListLoadedImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListErrorImplCopyWith<$Res> {
  factory _$$ListErrorImplCopyWith(
          _$ListErrorImpl value, $Res Function(_$ListErrorImpl) then) =
      __$$ListErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ListErrorImplCopyWithImpl<$Res>
    extends _$RecurringIncomesListStateCopyWithImpl<$Res, _$ListErrorImpl>
    implements _$$ListErrorImplCopyWith<$Res> {
  __$$ListErrorImplCopyWithImpl(
      _$ListErrorImpl _value, $Res Function(_$ListErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ListErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ListErrorImpl implements _ListError {
  const _$ListErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'RecurringIncomesListState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ListErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ListErrorImplCopyWith<_$ListErrorImpl> get copyWith =>
      __$$ListErrorImplCopyWithImpl<_$ListErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<RecurringIncomeStatus> incomeStatuses, String? filter,
            RecurringIncomeFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ListError implements RecurringIncomesListState {
  const factory _ListError({required final String message}) = _$ListErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$ListErrorImplCopyWith<_$ListErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ListEmptyImplCopyWith<$Res> {
  factory _$$ListEmptyImplCopyWith(
          _$ListEmptyImpl value, $Res Function(_$ListEmptyImpl) then) =
      __$$ListEmptyImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ListEmptyImplCopyWithImpl<$Res>
    extends _$RecurringIncomesListStateCopyWithImpl<$Res, _$ListEmptyImpl>
    implements _$$ListEmptyImplCopyWith<$Res> {
  __$$ListEmptyImplCopyWithImpl(
      _$ListEmptyImpl _value, $Res Function(_$ListEmptyImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ListEmptyImpl implements _ListEmpty {
  const _$ListEmptyImpl();

  @override
  String toString() {
    return 'RecurringIncomesListState.empty()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ListEmptyImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() loading,
    required TResult Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)
        loaded,
    required TResult Function(String message) error,
    required TResult Function() empty,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? loading,
    TResult? Function(
            List<RecurringIncomeStatus> incomeStatuses,
            String? filter,
            RecurringIncomeFrequency? frequencyFilter,
            String? categoryFilter)?
        loaded,
    TResult? Function(String message)? error,
    TResult? Function()? empty,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? loading,
    TResult Function(List<RecurringIncomeStatus> incomeStatuses, String? filter,
            RecurringIncomeFrequency? frequencyFilter, String? categoryFilter)?
        loaded,
    TResult Function(String message)? error,
    TResult Function()? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ListInitial value) initial,
    required TResult Function(_ListLoading value) loading,
    required TResult Function(_ListLoaded value) loaded,
    required TResult Function(_ListError value) error,
    required TResult Function(_ListEmpty value) empty,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ListInitial value)? initial,
    TResult? Function(_ListLoading value)? loading,
    TResult? Function(_ListLoaded value)? loaded,
    TResult? Function(_ListError value)? error,
    TResult? Function(_ListEmpty value)? empty,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ListInitial value)? initial,
    TResult Function(_ListLoading value)? loading,
    TResult Function(_ListLoaded value)? loaded,
    TResult Function(_ListError value)? error,
    TResult Function(_ListEmpty value)? empty,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _ListEmpty implements RecurringIncomesListState {
  const factory _ListEmpty() = _$ListEmptyImpl;
}

/// @nodoc
mixin _$RecurringIncomeReceiptState {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(
            RecurringIncome income, RecurringIncomeInstance instance)
        success,
    required TResult Function(String message) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult? Function(String message)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReceiptInitial value) initial,
    required TResult Function(_ReceiptProcessing value) processing,
    required TResult Function(_ReceiptSuccess value) success,
    required TResult Function(_ReceiptError value) error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReceiptInitial value)? initial,
    TResult? Function(_ReceiptProcessing value)? processing,
    TResult? Function(_ReceiptSuccess value)? success,
    TResult? Function(_ReceiptError value)? error,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReceiptInitial value)? initial,
    TResult Function(_ReceiptProcessing value)? processing,
    TResult Function(_ReceiptSuccess value)? success,
    TResult Function(_ReceiptError value)? error,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $RecurringIncomeReceiptStateCopyWith<$Res> {
  factory $RecurringIncomeReceiptStateCopyWith(
          RecurringIncomeReceiptState value,
          $Res Function(RecurringIncomeReceiptState) then) =
      _$RecurringIncomeReceiptStateCopyWithImpl<$Res,
          RecurringIncomeReceiptState>;
}

/// @nodoc
class _$RecurringIncomeReceiptStateCopyWithImpl<$Res,
        $Val extends RecurringIncomeReceiptState>
    implements $RecurringIncomeReceiptStateCopyWith<$Res> {
  _$RecurringIncomeReceiptStateCopyWithImpl(this._value, this._then);

  // ignore: unused_field
  final $Val _value;
  // ignore: unused_field
  final $Res Function($Val) _then;
}

/// @nodoc
abstract class _$$ReceiptInitialImplCopyWith<$Res> {
  factory _$$ReceiptInitialImplCopyWith(_$ReceiptInitialImpl value,
          $Res Function(_$ReceiptInitialImpl) then) =
      __$$ReceiptInitialImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ReceiptInitialImplCopyWithImpl<$Res>
    extends _$RecurringIncomeReceiptStateCopyWithImpl<$Res,
        _$ReceiptInitialImpl> implements _$$ReceiptInitialImplCopyWith<$Res> {
  __$$ReceiptInitialImplCopyWithImpl(
      _$ReceiptInitialImpl _value, $Res Function(_$ReceiptInitialImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ReceiptInitialImpl implements _ReceiptInitial {
  const _$ReceiptInitialImpl();

  @override
  String toString() {
    return 'RecurringIncomeReceiptState.initial()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ReceiptInitialImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(
            RecurringIncome income, RecurringIncomeInstance instance)
        success,
    required TResult Function(String message) error,
  }) {
    return initial();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult? Function(String message)? error,
  }) {
    return initial?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReceiptInitial value) initial,
    required TResult Function(_ReceiptProcessing value) processing,
    required TResult Function(_ReceiptSuccess value) success,
    required TResult Function(_ReceiptError value) error,
  }) {
    return initial(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReceiptInitial value)? initial,
    TResult? Function(_ReceiptProcessing value)? processing,
    TResult? Function(_ReceiptSuccess value)? success,
    TResult? Function(_ReceiptError value)? error,
  }) {
    return initial?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReceiptInitial value)? initial,
    TResult Function(_ReceiptProcessing value)? processing,
    TResult Function(_ReceiptSuccess value)? success,
    TResult Function(_ReceiptError value)? error,
    required TResult orElse(),
  }) {
    if (initial != null) {
      return initial(this);
    }
    return orElse();
  }
}

abstract class _ReceiptInitial implements RecurringIncomeReceiptState {
  const factory _ReceiptInitial() = _$ReceiptInitialImpl;
}

/// @nodoc
abstract class _$$ReceiptProcessingImplCopyWith<$Res> {
  factory _$$ReceiptProcessingImplCopyWith(_$ReceiptProcessingImpl value,
          $Res Function(_$ReceiptProcessingImpl) then) =
      __$$ReceiptProcessingImplCopyWithImpl<$Res>;
}

/// @nodoc
class __$$ReceiptProcessingImplCopyWithImpl<$Res>
    extends _$RecurringIncomeReceiptStateCopyWithImpl<$Res,
        _$ReceiptProcessingImpl>
    implements _$$ReceiptProcessingImplCopyWith<$Res> {
  __$$ReceiptProcessingImplCopyWithImpl(_$ReceiptProcessingImpl _value,
      $Res Function(_$ReceiptProcessingImpl) _then)
      : super(_value, _then);
}

/// @nodoc

class _$ReceiptProcessingImpl implements _ReceiptProcessing {
  const _$ReceiptProcessingImpl();

  @override
  String toString() {
    return 'RecurringIncomeReceiptState.processing()';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType && other is _$ReceiptProcessingImpl);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(
            RecurringIncome income, RecurringIncomeInstance instance)
        success,
    required TResult Function(String message) error,
  }) {
    return processing();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult? Function(String message)? error,
  }) {
    return processing?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReceiptInitial value) initial,
    required TResult Function(_ReceiptProcessing value) processing,
    required TResult Function(_ReceiptSuccess value) success,
    required TResult Function(_ReceiptError value) error,
  }) {
    return processing(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReceiptInitial value)? initial,
    TResult? Function(_ReceiptProcessing value)? processing,
    TResult? Function(_ReceiptSuccess value)? success,
    TResult? Function(_ReceiptError value)? error,
  }) {
    return processing?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReceiptInitial value)? initial,
    TResult Function(_ReceiptProcessing value)? processing,
    TResult Function(_ReceiptSuccess value)? success,
    TResult Function(_ReceiptError value)? error,
    required TResult orElse(),
  }) {
    if (processing != null) {
      return processing(this);
    }
    return orElse();
  }
}

abstract class _ReceiptProcessing implements RecurringIncomeReceiptState {
  const factory _ReceiptProcessing() = _$ReceiptProcessingImpl;
}

/// @nodoc
abstract class _$$ReceiptSuccessImplCopyWith<$Res> {
  factory _$$ReceiptSuccessImplCopyWith(_$ReceiptSuccessImpl value,
          $Res Function(_$ReceiptSuccessImpl) then) =
      __$$ReceiptSuccessImplCopyWithImpl<$Res>;
  @useResult
  $Res call({RecurringIncome income, RecurringIncomeInstance instance});

  $RecurringIncomeCopyWith<$Res> get income;
  $RecurringIncomeInstanceCopyWith<$Res> get instance;
}

/// @nodoc
class __$$ReceiptSuccessImplCopyWithImpl<$Res>
    extends _$RecurringIncomeReceiptStateCopyWithImpl<$Res,
        _$ReceiptSuccessImpl> implements _$$ReceiptSuccessImplCopyWith<$Res> {
  __$$ReceiptSuccessImplCopyWithImpl(
      _$ReceiptSuccessImpl _value, $Res Function(_$ReceiptSuccessImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? income = null,
    Object? instance = null,
  }) {
    return _then(_$ReceiptSuccessImpl(
      income: null == income
          ? _value.income
          : income // ignore: cast_nullable_to_non_nullable
              as RecurringIncome,
      instance: null == instance
          ? _value.instance
          : instance // ignore: cast_nullable_to_non_nullable
              as RecurringIncomeInstance,
    ));
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeCopyWith<$Res> get income {
    return $RecurringIncomeCopyWith<$Res>(_value.income, (value) {
      return _then(_value.copyWith(income: value));
    });
  }

  @override
  @pragma('vm:prefer-inline')
  $RecurringIncomeInstanceCopyWith<$Res> get instance {
    return $RecurringIncomeInstanceCopyWith<$Res>(_value.instance, (value) {
      return _then(_value.copyWith(instance: value));
    });
  }
}

/// @nodoc

class _$ReceiptSuccessImpl implements _ReceiptSuccess {
  const _$ReceiptSuccessImpl({required this.income, required this.instance});

  @override
  final RecurringIncome income;
  @override
  final RecurringIncomeInstance instance;

  @override
  String toString() {
    return 'RecurringIncomeReceiptState.success(income: $income, instance: $instance)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReceiptSuccessImpl &&
            (identical(other.income, income) || other.income == income) &&
            (identical(other.instance, instance) ||
                other.instance == instance));
  }

  @override
  int get hashCode => Object.hash(runtimeType, income, instance);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReceiptSuccessImplCopyWith<_$ReceiptSuccessImpl> get copyWith =>
      __$$ReceiptSuccessImplCopyWithImpl<_$ReceiptSuccessImpl>(
          this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(
            RecurringIncome income, RecurringIncomeInstance instance)
        success,
    required TResult Function(String message) error,
  }) {
    return success(income, instance);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult? Function(String message)? error,
  }) {
    return success?.call(income, instance);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(income, instance);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReceiptInitial value) initial,
    required TResult Function(_ReceiptProcessing value) processing,
    required TResult Function(_ReceiptSuccess value) success,
    required TResult Function(_ReceiptError value) error,
  }) {
    return success(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReceiptInitial value)? initial,
    TResult? Function(_ReceiptProcessing value)? processing,
    TResult? Function(_ReceiptSuccess value)? success,
    TResult? Function(_ReceiptError value)? error,
  }) {
    return success?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReceiptInitial value)? initial,
    TResult Function(_ReceiptProcessing value)? processing,
    TResult Function(_ReceiptSuccess value)? success,
    TResult Function(_ReceiptError value)? error,
    required TResult orElse(),
  }) {
    if (success != null) {
      return success(this);
    }
    return orElse();
  }
}

abstract class _ReceiptSuccess implements RecurringIncomeReceiptState {
  const factory _ReceiptSuccess(
      {required final RecurringIncome income,
      required final RecurringIncomeInstance instance}) = _$ReceiptSuccessImpl;

  RecurringIncome get income;
  RecurringIncomeInstance get instance;
  @JsonKey(ignore: true)
  _$$ReceiptSuccessImplCopyWith<_$ReceiptSuccessImpl> get copyWith =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class _$$ReceiptErrorImplCopyWith<$Res> {
  factory _$$ReceiptErrorImplCopyWith(
          _$ReceiptErrorImpl value, $Res Function(_$ReceiptErrorImpl) then) =
      __$$ReceiptErrorImplCopyWithImpl<$Res>;
  @useResult
  $Res call({String message});
}

/// @nodoc
class __$$ReceiptErrorImplCopyWithImpl<$Res>
    extends _$RecurringIncomeReceiptStateCopyWithImpl<$Res, _$ReceiptErrorImpl>
    implements _$$ReceiptErrorImplCopyWith<$Res> {
  __$$ReceiptErrorImplCopyWithImpl(
      _$ReceiptErrorImpl _value, $Res Function(_$ReceiptErrorImpl) _then)
      : super(_value, _then);

  @pragma('vm:prefer-inline')
  @override
  $Res call({
    Object? message = null,
  }) {
    return _then(_$ReceiptErrorImpl(
      message: null == message
          ? _value.message
          : message // ignore: cast_nullable_to_non_nullable
              as String,
    ));
  }
}

/// @nodoc

class _$ReceiptErrorImpl implements _ReceiptError {
  const _$ReceiptErrorImpl({required this.message});

  @override
  final String message;

  @override
  String toString() {
    return 'RecurringIncomeReceiptState.error(message: $message)';
  }

  @override
  bool operator ==(Object other) {
    return identical(this, other) ||
        (other.runtimeType == runtimeType &&
            other is _$ReceiptErrorImpl &&
            (identical(other.message, message) || other.message == message));
  }

  @override
  int get hashCode => Object.hash(runtimeType, message);

  @JsonKey(ignore: true)
  @override
  @pragma('vm:prefer-inline')
  _$$ReceiptErrorImplCopyWith<_$ReceiptErrorImpl> get copyWith =>
      __$$ReceiptErrorImplCopyWithImpl<_$ReceiptErrorImpl>(this, _$identity);

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() initial,
    required TResult Function() processing,
    required TResult Function(
            RecurringIncome income, RecurringIncomeInstance instance)
        success,
    required TResult Function(String message) error,
  }) {
    return error(message);
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult? Function()? initial,
    TResult? Function()? processing,
    TResult? Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult? Function(String message)? error,
  }) {
    return error?.call(message);
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? initial,
    TResult Function()? processing,
    TResult Function(RecurringIncome income, RecurringIncomeInstance instance)?
        success,
    TResult Function(String message)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(message);
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_ReceiptInitial value) initial,
    required TResult Function(_ReceiptProcessing value) processing,
    required TResult Function(_ReceiptSuccess value) success,
    required TResult Function(_ReceiptError value) error,
  }) {
    return error(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult? Function(_ReceiptInitial value)? initial,
    TResult? Function(_ReceiptProcessing value)? processing,
    TResult? Function(_ReceiptSuccess value)? success,
    TResult? Function(_ReceiptError value)? error,
  }) {
    return error?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_ReceiptInitial value)? initial,
    TResult Function(_ReceiptProcessing value)? processing,
    TResult Function(_ReceiptSuccess value)? success,
    TResult Function(_ReceiptError value)? error,
    required TResult orElse(),
  }) {
    if (error != null) {
      return error(this);
    }
    return orElse();
  }
}

abstract class _ReceiptError implements RecurringIncomeReceiptState {
  const factory _ReceiptError({required final String message}) =
      _$ReceiptErrorImpl;

  String get message;
  @JsonKey(ignore: true)
  _$$ReceiptErrorImplCopyWith<_$ReceiptErrorImpl> get copyWith =>
      throw _privateConstructorUsedError;
}
